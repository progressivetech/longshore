# This file should be sourced by all scripts. It contains
# shared functions

# Variables that can be set via the environment are:
# LONG_DRUSH_ARGS - to pass arbitrary args to all drush invocations,
#   such as --debug or -v
# LONG_YES - to bypass any prompts that this libraries handles
#   (that does not include drush prompts, so you may need to 
#   combine with LONG_DRUSH_ARGS=-y if you want to fully automate
#   a script).

# One liner for printing message and dying
# long_die $msg $exit_code $var $var
long_die() {
  local msg="$1"
  local exit_code="$2"
  shift 2
  [ -z "$exit_code" ] && exit_code=1
  long_log "$msg" error "$@"
  exit "$exit_code"
}

# Return defined $long_usage_message and die 
long_usage() {
  local exit_code="$1"
  [ -z "$exit_code" ] && exit_code=1
  long_die "$long_usage_message" "$exit_code"
}

# Ensure the number of required arguments have been passed
# and if not, run long_usage (which will exit). Also, parse
# global arguments (like -f for force).
long_check_args() {
  # The sub command is one argument that we don't count, so subtract 1 from 
  # the number of arguments passed.
  local first_arg="$1"
  local num_passed=$(( $2 - 1 ))
  local num_required="$3"
  [ -z "$num_passed" ] && num_passed=0
  [ -z "$num_required" ] && num_required=0
  if [ "$first_arg" = "-h" ] || [ "$first_arg" = "--help" ]; then
    long_usage  
  fi 
  if [ "$num_passed" -lt "$num_required" ] ; then
    long_log "Not enough arguments passed. Expecting at least %s, received %s.\n" \
      error "$num_required" "$num_passed"
    long_usage
  fi
}

# Given a site, set the ssh variable to empty if it should 
# be run locally or a working ssh command that connects to
# the appropriate frontend.
long_set_ssh_command() {
  local site="$1"
  local host=$(hostname)
  frontend=$(ptp-get-frontend-for-site "$site")
  LONG_SSH=
  [ -n "$frontend" ] && [ "$host" != "$frontend" ] && LONG_SSH="ssh ${frontend}.mayfirst.org"
}

# Given a site, check if we should connect to a remote aegir frontend to run
# the given command that was called (in which case, make the connection and run
# the command) or run it locally. This function should be called by scripts
# that need to be run locally.
long_rerun_over_network() { 
  local site="$1"
  long_set_ssh_command "$site"
  # Return 0 (aka success) to indicate that we did
  # run the command over ssh
  if [ -n "$LONG_SSH" ]; then
    $LONG_SSH "$0" "$site" "$2" "$3"
    return 0
  fi
  # Return 1 (aka failure) to indicate that we didn't
  # rerun it over the network and the script should
  # proceed to run it locally.
  return 1
}

# Prompt the user with a given message ($1) and the question
# "Proceed? [Yn]" - set $reply variable to either y or n, properly
# parsing case and the default.
long_prompt() {
  local prompt_msg=$1
  shift
  printf "${prompt_msg}\n" "$@"
  if [ "$LONG_YES" = "1" ]; then
    printf " Automatically proceeding without prompt.\n"
    # reply is a global - exception to the rule of all capitals and 
    # LONG prefix.
    reply=y
    return
  fi
  read -p "Proceed? [Yn] "
  reply=n
  if [ -z "$REPLY" ] || [ "$REPLY" == "Y" ] || [ "$REPLY" == "y" ]; then
    reply=y
  fi
}

# Either output a message to standard error or send it by email
# depending on whether we are running from a cron job or not
long_debug() {
  local debug_msg="$1"
  local debug_subject="$2"
  local deubg_pid="$!"
  if grep -q cron /proc/"$debug_pid"/cmdline &> /dev/null; then
    echo "$debug_msg" | mail -s "$debug_subj" "$LONG_DEBUG_EMAIL"
  else
    echo "$debug_subject" >&2
    echo "$deubg_msg" >&2
  fi
  exit 1
}

# Check if a conatiner with the given name exists or not.
# Return 0 if it exists and 1 if it doesn't.
long_container_exists() {
  long_container_or_image_exists "$1"
}

# Inspect seems to work for both containers and images.
long_container_or_image_exists() {
  local name="$1"
  [ -z "$name" ] && return 1
  # This command returns 1 if the container doesn't exist and 0 if it does.
  docker inspect "$name" 2>/dev/null 1>/dev/null
  return "$?"
}

# Check if a conatiner with the given name is running or not.
# Return 0 if it is running and 1 if it isn't.
long_container_running() {
  local name="$1"
  [ -z "$name" ] && return 1
  container_running=$(docker inspect -f {{.State.Running}} "$name")
  [ "$container_running" = "true" ] && return 0
  return 1
}

# Check if an image with the given name exists.
# Return 0 if it exists and 1 if it doesn't.
long_image_exists() {
  long_container_or_image_exists "$1"
}

# Generate a my.cnf file with the given info
long_generate_my_cnf() {
  local dir="$1"
  local password="$2"
  local port="$3"
  local user="$4"

  [ -z "$user" ] && user=root
  printf "[client]\nuser=%s\npassword=%s\nport=%s\nhost=127.0.0.1\n" \
    "$user" "$password" "$port" > \
    "$dir"/my.cnf

  # If this is a site my.cnf file, add the database name.
  if [ "$user" != "root" ]; then
    printf "[mysql]\ndatabase=%s\n" "$user" >> "$dir"/my.cnf
  fi
}

# Generate a random password
long_pwgen() {
  # Excluding characters that commonly cause problems. Sigh.
  LONG_PASSWORD=$(hexdump -e '"%_p"' /dev/urandom | tr -d '[:punct:] \n' | head -c 25)
}

# Output logging info based on log level
# long_log $msg $log_level $var $var
# log levels: info, error, critical
long_log() {
  local log_msg="$1"
  local log_level="$2"
  shift 2
  local log_out=n
  # Always output critical
  if [ "$log_level" = "critical" ]; then
    log_out=y
  fi
  # Output error if we are set to info or error
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "info" ];  then
    log_out=y
  fi
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "error" ];  then
    log_out=y
  fi
  # Output info if we are set to info
  if [ "$log_level" = "info" -a "$LONG_LOG_LEVEL" = "info" ];  then
    log_out=y
  fi
  if [ "$log_out" = "y" ]; then
    printf "$log_msg\n" "$@"
  fi
}

# Save the generic tls configuration for all sites
long_create_nginx_tls_conf() {
  local template="${LONG_SHARE}/templates/nginx-tls.conf"
  local target="$LONG_NGINX_TLS_PATH"
  cat "$template" | \
    sed \
    -e "s:LONG_TLS_KEY_PATH:$LONG_TLS_KEY_PATH:" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    -e "s:LONG_X509_CERT_PATH:$LONG_X509_CERT_PATH:" \
    -e "s:LONG_DH_PARAM_PATH:$LONG_DH_PARAM_PATH:" \
    > "$target"
}

# save the phpmyadmin nginx configuration file
long_create_nginx_phpmyadmin_conf() {
  local port="$1"
  local template="${LONG_SHARE}/templates/nginx-phpmyadmin.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/phpmyadmin.conf"
  LONG_SITE_URL="$LONG_PHPMYADMIN_URL"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    LONG_TLS_OR_NOT="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect phpmyadmin "$LONG_SITE_URL"
  else
    LONG_TLS_OR_NOT="listen ${LONG_IP_ADDR}:80;"
  fi
  LONG_CGI_PORT="$port"
  cat "$template" | \
    sed \
    -e "s:LONG_TLS_OR_NOT:$LONG_TLS_OR_NOT:" \
    -e "s:LONG_SITE_URL:$LONG_SITE_URL:" \
    -e "s:LONG_CGI_PORT:$LONG_CGI_PORT:" \
    > "$target"
}

# Pass the short site name as first argument and the full
# URL as the second.
long_create_nginx_redirect() {
  local site="$1"
  local site_url="$2"
  local template="${LONG_SHARE}/templates/nginx-redirect-https.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/${site}-redirect.conf"
  cat "$template" | \
    sed \
    -e "s#LONG_SITE_URL#$site_url#" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    > "$target"
}

# Save an nginx server configuration file
long_create_nginx_site_conf() {
  local site="$1"
  local platform="$2"
  local port="$3"

  local template="${LONG_SHARE}/templates/nginx-site.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/${site}.conf"
  LONG_SITE_URL="${site}.${LONG_DEFAULT_DOMAIN}"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    LONG_TLS_OR_NOT="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect "$site" "$LONG_SITE_URL"
  else
    LONG_TLS_OR_NOT="listen ${LONG_IP_ADDR}:80;"
  fi
  LONG_ACCESS_LOG="${site}.access.log"
  LONG_WEB_ROOT="/var/www/powerbase/${platform}"
  LONG_PHP_ROOT="/var/www/powerbase"
  LONG_CGI_PORT="$port"

  cat "$template" | \
    sed \
    -e "s#LONG_TLS_OR_NOT#$LONG_TLS_OR_NOT#" \
    -e "s#LONG_ACCESS_LOG#$LONG_ACCESS_LOG#" \
    -e "s#LONG_SITE_URL#$LONG_SITE_URL#" \
    -e "s#LONG_WEB_ROOT#$LONG_WEB_ROOT#" \
    -e "s#LONG_PHP_ROOT#$LONG_PHP_ROOT#" \
    -e "s#LONG_CGI_PORT#$LONG_CGI_PORT#" \
    -e "s#LONG_SITE#$site#" \
    > "$target"
}

# Return 0 if it's the latest and 1 if it's not and 2 for an error.
long_phpmyadmin_is_latest() {
  # Check version installed
  local installed=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/README" ]; then
    installed=$(head "${LONG_SRV}/services/phpmyadmin/src/README" | grep '^Version' | cut -d\  -f2)
  else
    # It's not installed at all, that means not the latest.
    return 1 
  fi

  [ -z "$installed" ] && return 2 

  local latest=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/version_check.php" ]; then
    latest=$(cd "${LONG_SRV}/services/phpmyadmin/src/" && php version_check.php | tr -d '{}"' | cut -d, -f1 | cut -d: -f2)
  else
    # Something is broken if we don't have this file
    return 2 
  fi

  [ -z "$latest" ] && return 2 

  [ "$latest" = "$installed" ]  && return 0
  return 1
}

# This variable containing the names of all database containers
long_db_containers() {
  LONG_DB_CONTAINERS=$(ls "${LONG_SRV}/services/databases/")
}

# Create if necessary the given image
# first argument is tag, second is path to docker directory
long_image_create() {
  local image_tag="$1"
  local image_path="$2"
  if ! long_image_exists "$image_tag"; then
    long_log "Creating image (%s)" info "$image_tag"
    if [ "$image_tag" = "my-jessie" ]; then
      # This is a special condition
      long_image_create_base
    else
      docker build -t "$image_tag" "$image_path"
    fi
  fi
}

# Create the base image
long_image_create_base() {
  long_log "Creating base image" info
  sudo /usr/local/sbin/longshore-create-base-image
}

# Delete, if necessary, the image
long_image_delete() {
  local tag="$1"
  if long_image_exists "$tag"; then
    long_log "Deleting  image (%s)" info "$tag"
    docker rmi "$tag"
  fi
}

# Create (if necessary) and start (if necessary) a given container
long_container_up() {
  local type="$1"
  local name="$2"
  local db="$3"
  local platform="$4"

  # phpmyadmin will be called with just the type variable set.
  # In these cases, we use the type as the name - since we only have one
  # one phpmyadmin container.
  local label="$name"
  [ -z "$label" ] && label="$type"

  # long_create_container will check if it exists first and respect MF_FORCE.
  long_create_container "$type" "$name" "$db" "$platform"

  if ! long_container_running "$label"; then
    long_log "Starting container (%s)" info "$label"
    if [ "$type" = "site" ]; then
      # Ensure db container is running first.
      long_get_db_for_site "$name"
      long_container_up mysql "$LONG_DB_HOST"
    fi
    docker start "$label"
  fi
}

# Stop (if necessary) and delete (if necessary) the named container
long_container_destroy() {
  local name="$1"
  if long_container_exists "$name"; then
    if long_container_running "$name"; then
      long_log "Stopping container (%s)" info "$name"
      docker stop "$name" 
    fi
    long_log "Removing container (%s)" info "$name"
    docker rm "$name" 
  fi
}

# Reload nginx to pickup new configurations
long_nginx_reload() {
  sudo /etc/init.d/nginx reload
}

# Get the port for this mysql container, or assign a new one.
long_get_mysql_port() {
  local name="$1"
  local dir="${LONG_SRV}/services/databases/${name}"
  local last_port=
  if [ -f "$dir/my.cnf" ]; then
    LONG_DB_PORT=$(grep port "${dir}/my.cnf" | cut -d= -f2)
  else
    # If we don't already have a .my.cnf file, find the next available port.
    last_port=$(grep port= "${LONG_SRV}/services/databases/*/my.cnf" 2>/dev/null | cut -d= -f2 | sort -n | tail -n 1)
    if [ -z "$last_port" ]; then
      LONG_DB_PORT="$LONG_MYSQL_START_PORT"
    else
      LONG_DB_PORT=$(( $last_port + 1 ))
    fi
  fi
}

# Get the port for this php container, or assign a new one.
long_get_php_port() {
  local name="$1"
  local envdir=
  local last_port=
  if [ "$name" = "phpmyadmin" ]; then
    envdir="${LONG_SRV}/services/phpmyadmin/env"
  else
    envdir="${LONG_SRV}/services/sites/${name}/env"
  fi
  if [ -f "${envdir}/PORT" ]; then
    LONG_PHP_PORT=$(cat "${envdir}/PORT")
  else
    # If we don't already have a PORT file, find the next available port.
    last_port=$(cat "${LONG_SRV}/services/phpmyadmin/env/PORT" "${LONG_SRV}"/services/sites/*/env/PORT 2>/dev/null | sort -n | tail -n1)
    if [ -z "$last_port" ]; then
      LONG_PHP_PORT="$LONG_PHP_START_PORT"
    else
      LONG_PHP_PORT=$(( $last_port + 1 ))
    fi
    mkdir -p "$envdir"
    echo "$LONG_PHP_PORT" > "${envdir}/PORT"
  fi
}

# Take the passed in var and sanitize for sql statement
long_sql_sanitize_var() {
  LONG_SANE_VAR=$(echo "$1" | sed 's/[^0-9a-z]//g')
}

# Create a database and database user for the given site, db name
# and password.
long_create_db() {
  local site="$1"
  long_sql_sanitize_var "$site"
  site="$LONG_SANE_VAR"
  local dbname="$site"
  local dbuser="$site"
  local dbhost="$2"
  
  local temp=$(mktemp)

  # Always ensure database exists. This is easy, idempotent.
  echo "CREATE DATABASE IF NOT EXISTS \`$dbname\`;" > "$temp"

  # Only ensure the user/password exists if we don't have a my.cnf file.
  local dir="${LONG_SRV}/services/sites/${name}"
  local mycnf_file="${dir}/my.cnf"
  if [ ! -f "$mycnf_file" ]; then 
    # Generate random password.
    long_log "Generating database password." info
    long_pwgen
    echo "GRANT ALL ON \`$dbname\`.* TO '$dbuser'@'%' IDENTIFIED BY '$LONG_PASSWORD';" >> "$temp"

    # Get the LONG_DB_PORT for this database host.
    long_get_mysql_port "$dbhost"
    long_generate_my_cnf "$dir" "$LONG_PASSWORD" "$LONG_DB_PORT" "$site"
  fi

  while ! long_up_long_enough "$dbhost" 30; do
    long_log "Waiting 10 more seconds to ensure database has started." info
    sleep 10 
  done
  long_execute_root_query "$dbhost" "$temp"
  rm "$temp"
}

# Return 0 if the given site has been up more than the specified number of
# seconds. Otherwise 1.  Useful for determining whether we can expect MySQL to
# be ready to receive a sql query.
long_up_long_enough() {
  local site="$1"
  local seconds="$2"
  local site_up_iso=$(docker inspect -f {{.State.StartedAt}} "$site")
  local now_ts=$(date '+%s')
  local site_up_ts=$(date --utc --date "$site_up_iso" '+%s')
  local diff=$(( $now_ts - $site_up_ts ))
  if [ "$diff" -gt "$seconds" ]; then
    return 0
  fi
  return 1
}

# Execute the queries in the passed in file on the given database as the
# site's non-privileged user.
long_execute_site_query() {
  local site="$1"
  local file="$2"

  if [ ! -f "$file" ]; then
    long_die "Can't find file with queries to execute."
  fi

  long_get_db_for_site "$site"

  # Make sure the db container exists
  long_container_exists "$LONG_DB_HOST"

  if [ "$?" != 0 ]; then
    long_die "The database container doesn't exist (%s)" 1 "$LONG_DB_HOST"
  fi

  long_container_running "$LONG_DB_HOST"
  if [ "$?" != 0 ]; then
    long_die "The database container isn't running (%s)" 1 "$LONG_DB_HOST"
  fi

  mycnf="${LONG_SRV}/services/sites/${site}/my.cnf"
  if [ ! -f "$mycnf" ]; then
    long_die "The my.cnf file doesn't exist for this site (%s)" 1 "$mycnf"
  fi
  
  # We should be able to handle gzip or non-gzipped files.
  cmd=cat
  if file -b "$file" | grep "^gzip" >/dev/null; then
    cmd="gunzip -c"
  fi
  # Strip definer statements since we are running as a non-privileged user
  # to avoid "You need SUPER privileges" for this operation..
  $cmd "$file" | sed 's#/\*!5001[37] DEFINER=[^*]*\*/# #g' | mysql --defaults-file="$mycnf"
}

# Execute the queries in the passed in file on the given database as the
# db root user.
long_execute_root_query() {
  local db="$1"
  local file="$2"

  if [ ! -f "$file" ]; then
    long_die "Can't find file with queries to execute."
  fi

  # Make sure the db container exists
  long_container_exists "$db"

  if [ "$?" != 0 ]; then
    long_die "The database container doesn't exist (%s)" 1 "$db"
  fi

  long_container_running "$db"
  if [ "$?" != 0 ]; then
    long_die "The database container isn't running (%s)" 1 "$db"
  fi

  mycnf="${LONG_SRV}/services/databases/${db}/my.cnf"
  if [ ! -f "$mycnf" ]; then
    long_die "The my.cnf file doesn't exist for this database (%s)" 1 "$mycnf"
  fi
  
  mysql --defaults-file="$mycnf" < "$file"
}

# Initialize the LONG_SITE_TMP variable. 
long_init_site_tmp_var() {
  local name="$1"
  LONG_SITE_TMP="${LONG_SRV}/services/sites/${name}/drupal/private/temp"
}

# Create a drupal settings.php file.
long_create_drupal_settings() {
  local site="$1"
  local db="$2"

  local dir="${LONG_SRV}/services/sites/${site}"
  local pass=$(grep password "${dir}/my.cnf" | cut -d= -f2)
  long_get_platform_for_site "$site"
  local source="${LONG_SRV}/platforms/${LONG_PLATFORM}/sites/default/default.settings.php"
  local target="${dir}/drupal/settings.php"

  # Copy the template into place.
  cp "$source" "$target"

  # And then append the database configuration.
  source="${LONG_SHARE}/templates/db.php"
  cat "$source" | \
    sed \
    -e "s:LONG_DB_NAME:$site:" \
    -e "s#LONG_DB_USER#$site#" \
    -e "s#LONG_PASSWORD#$pass#" \
    -e "s#LONG_DB_HOST#$db#" \
    >> "$target"
  # Ensure proper permissions
  chmod 0640 "$target"
  sudo chgrp longshore-php "$target"
}

# Give a site, set a variable for the base_url
long_get_base_url_for_site() {
  site="$1"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    protocol='https://'
  else
    protocol='http://'
  fi

  LONG_BASE_URL="${protocol}${site}.${LONG_DEFAULT_DOMAIN}"
}

# Create civicrm settings file.
long_create_civicrm_settings() {
  local site="$1"

  # Grant the longshore-php group write access to the container default dir so
  # it can create the civicrm.settings.php file (the longshore-php user should
  # already have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  long_get_base_url_for_site "$site"
  long_exec_drush_cmd "$site" "lsd-civicrm-settings --base_url='$LONG_BASE_URL'"

  # Ensure proper permissions
  local target="${LONG_SRV}/services/sites/${site}/drupal/civicrm.settings.php"
  sudo chown longshore "$target"
  chmod 0640 "$target"

  # Remove write access.
  chmod 755 "${dir}/drupal"
}

# Execute the given drush command in the given container as the www-data user.
long_exec_drush_cmd() {
  site="$1"
  cmd="$2"

  long_init_site_tmp_var "$site"
  local file=$(mktemp "${LONG_SITE_TMP}/drupal.XXXXXXX");
  chmod 755 "$file"
  printf "#!/bin/bash\n" > "$file"
  printf "export LONG_LIVE=$LONG_LIVE\n" >> "$file"
  printf 'cd /var/www/powerbase/sites/default && ' >> "$file"
  printf "drush $2\n" >> "$file"
  long_exec_in_container "$site" "$file"
  rm "$file"
}

# Execute the given command in the given container as www-data. 
long_exec_in_container() {
  local site="$1"
  local cmd="$2"

  # If the file to execute is in $LONG_SITE_TMP, then we need to translate
  # the path to where it will exist in the site container.
  local dir=$(dirname "$cmd")
  if [ "$dir" = "$LONG_SITE_TMP" ]; then
    cmd="/var/www/powerbase/sites/default/private/temp/$(basename $cmd)"
  fi
  docker exec -i -t "$site" su -l -c "$cmd" www-data
}

# Low lever mysql container creation. Call long_create_container instead
# if possible.
long_create_mysql_container() {
  local name="$1"
  local dir="${LONG_SRV}/services/databases/${name}"
  # Make sure our base directory and a mysql sub directory exists.
  # Our my.cnf file will go in ${dir}/my.cnf and be mounted in the host
  # in /mnt/my.cnf and ${dir}/mysql will get mounted at /var/lib/mysql.
  mkdir -p "${dir}/mysql"
  mkdir -p "${dir}/logs"

  # Get the port number. Each MySQL container is assigned a unique port
  # on the host. This will generate a LONG_DB_PORT variable.
  long_get_mysql_port "$name"

  # Check for existence of my.cnf file and create if necessary.
  if [ ! -f "${dir}/my.cnf" ]; then
    # Use our password generation utility which uses /dev/urandom.
    # long_pwgen will assign a new password to the variable $LONG_PASSWORD.
    long_pwgen

    long_generate_my_cnf "$dir" "$LONG_PASSWORD" "$LONG_DB_PORT"
  fi

  # Bail if the container already exists. 
  if long_container_exists "$name"; then
    return
  fi

  docker create --name "$name" \
    -v "${dir}/mysql":/var/lib/mysql \
    -v "${dir}/my.cnf:/root/.my.cnf" \
    -v "${dir}/logs:/var/log/mysql" \
    -e "LONG_LIVE=$LONG_LIVE" \
    -p "127.0.0.1:${LONG_DB_PORT}:3306" \
    $LONG_MEMORY_LIMIT \
    ptp-mysql:latest mysqld
}

# Low leverl phpmyadmin container creation. Call long_create_container instead
# if possible.
long_create_phpmyadmin_container() {
  local dir="${LONG_SRV}/services/phpmyadmin"
  # Make sure we have our base directories
  mkdir -p "$dir/src"

  # Create the server.list file with all db servers on this host
  long_db_containers
  echo "$LONG_DB_CONTAINERS" > "${dir}/src/servers.list"

  # FIXME - This is temporary while we are supporting both longshore and 
  # aegir. The phpmyadmin instance has to connect to the aegir servers 
  # too.
  local server=
  for server in $(ls -d /var/aegir/platforms/*-ourpowerbase-d7-c4.5 | sed 's/-ourpowerbase-d7-c4\.5$//' | cut -d/ -f5); do
    # On dev servers - master is used for localhost
    if [ "$server" = "master" ]; then
      continue
    else
      server="${server}.mayfirst.org"
    fi
    echo "$server" >> "${dir}/src/servers.list"
  done

  # Create the --link argument
  local link=
  for link_db in $long_db_containers; do
    link="$link --link $link_db:$link_db"
  done

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  long_get_php_port phpmyadmin

  # The phpmyadmin container has to be available via a local port since 
  # nginx, which is running on localhost, has to communicate with it.
  publish="-p 127.0.0.1:$LONG_PHP_PORT:9000"

  # Copy in the config.inc.php.sample file with blowfish secret
  long_pwgen
  cat ${LONG_SHARE}/templates/phpmyadmin.config.inc.php.sample | sed "s/BLOWFISHSECRET/$LONG_PASSWORD/" \
    > "${dir}/src/config.inc.php" 

  # Create nginx configuration
  long_create_nginx_phpmyadmin_conf "$LONG_PHP_PORT"

  # Bail if the container already exists. 
  if long_container_exists phpmyadmin; then
    return
  fi

  # Docker
  docker create --name phpmyadmin \
    -v "${dir}/src:/var/www/phpmyadmin" \
    $link \
    $publish \
    $LONG_MEMORY_LIMIT \
    ptp-php:latest php5-fpm 
}

# Build out the required directories and permissions
# for a given site.
long_create_site_directories() {
  local name="$1"
  local perms=
  local dir="${LONG_SRV}/services/sites/$name"

  # These are the main directories that should be readable the the web. 
  local creates="
    backup
    drupal
    drupal/custom-civicrm
    drupal/custom-civicrm/php
    drupal/custom-civicrm/templates
    drupal/files
    drupal/files/css
    drupal/files/js
    drupal/files/civicrm
    drupal/files/civicrm/persist
    drupal/modules
    drupal/themes
    drupal/libraries"
  local create=
  for create in $creates; do
    mkdir -p "${dir}/${create}"
    perms=$(stat -c "%A" "${dir}/${create}")
    if [ "$perms" != "drwxr-xr-x" ]; then
      chmod 0755 "${dir}/${create}"
      # Aegir makes some of these directories group sticky. We don't
      # need that anymore.
      chmod g-s "${dir}/${create}"
    fi
  done

  # Certain directories should not be accessible by the web user, only 
  # by the user running the PHP application.
  # See https://civicrm.org/advisory/civi-sa-2014-001-risk-information-disclosure
  # The private/extensions/{tmp,cache} are there *only* to handle the 
  # extensions tmp and cache directories. Extensions are in
  # sites/all/extensions and tmp and cache is symlinked here.
  local not_web_accessible="
    drupal/files/civicrm/ConfigAndLog
    drupal/files/civicrm/templates_c
    drupal/files/civicrm/upload
    drupal/files/civicrm/custom
    drupal/private
    drupal/private/extensions
    drupal/private/extensions/tmp
    drupal/private/extensions/cache"
  # Prohibit web access by removing other access. Only the user and the
  # group owners will be able to access the files. And only the owner will
  # be able to write to them.
  for create in $not_web_accessible; do
    # We only need to make this change at the top level - no need for
    # recursive.
    mkdir -p "${dir}/${create}"
    perms=$(stat -c "%A" "${dir}/${create}")
    if [ "$perms" != "drwxr-x---" ]; then
      chmod 0750 "${dir}/${create}" 
      # Aegir makes some of these directories group sticky. We don't
      # need that anymore.
      chmod g-s "${dir}/${create}"

    fi
  done

  # One more directory should be readable by the web user, but the web
  # user should not be able to get a directory listing. We can do that
  # by removing execute privileges, but keeping read privileges.
  mkdir -p "${dir}/drupal/files/civicrm/contribute"
  perms=$(stat -c "%A" "${dir}/drupal/files/civicrm/contribute")
  if [ "$perms" != "drwxr-xr--" ]; then
    chmod o-x "${dir}/drupal/files/civicrm/contribute"
    chmod g-s "${dir}/drupal/files/civicrm/contribute"
  fi

  # One exception: private/temp should be writable by the group (longshore)
  # so that the host can create temporary files to be deleted after being
  # executed in the container. See the long_exec_in_container function.
  mkdir -p "${dir}/drupal/private/temp"
  perms=$(stat -c "%A" "${dir}/drupal/private/temp")
  if [ "$perms" != "drwxrwxr-x" ]; then
    chmod 0775 "${dir}/drupal/private/temp"
    chmod g-s "${dir}/drupal/files/civicrm/contribute"
  fi

  # Now that the right modes are set, chown the files to the right users. 
  local web_writable="drupal/files drupal/private"
  for foo in $web_writable; do
    # Maintain group ownership by the longshore user so we can read the
    # files from the host for convenience and trouble-shooting.
    sudo chown -R longshore-php:longshore "${dir}/${foo}"
  done

  # Give the longshore-php user group ownership over the drupal directory
  # so we can easily flip on and off group write/read access when
  # installing drupal and civicrm.
  sudo chgrp longshore-php "${dir}/drupal"
}

# Low lever site container creation. Call long_create_container instead
# if possible.
long_create_site_container() {
  local name="$1"
  local db="$2"
  local platform="$3"

  local dir="${LONG_SRV}/services/sites/$name"

  # Sanity check - make sure platform exists.
  if [ ! -d "${LONG_SRV}/platforms/${platform}" ]; then
    long_die "That platform doesn't seem to exist (%s)." 1 "$platform"
  fi

  # Ensure that the database container exists and is running. It has to
  # be running, not just created, so we can create the database and database
  # username/password.
  #
  # Normally, we would simply call long_container_up - however, that 
  # function in turn calls long_container_create - which will try to 
  # create the mysql container while respecting the LONG_FORCE setting
  # intended for the site. We don't want to force re-ceate the database
  # container everytime we force re-create the site container.
  #
  # To avoid that problem, we first call the container create mysql helper 
  # function directly which will return if the container already exists.
  long_create_mysql_container "$db"
  long_container_up mysql "$db"

  # Build out directories. 
  long_create_site_directories "$name"

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  long_get_php_port "$name" 

  # Create nginx configuration
  long_create_nginx_site_conf "$site" "$platform" "$LONG_PHP_PORT"

  # Ensure that the database exists and that we have a my.cnf file.
  #
  # We are not going to do a proper drupal and civicrm installation 
  # because that will take a long time and we may only want to create
  # the container in order to import an existing database. So, just create
  # the database and user and record the password in my.cnf.
  #
  # The actual installation, if needed, will happen in longshore site-setup
  long_create_db "$name" "$db"

  # Bail if the container already exists. All remaining items in this
  # function are only needed if the site has never been created.
  if long_container_exists "$name"; then
    return
  fi 
  # Ensure the container is accessible on localhost so nginx can reach it.
  local publish="-p 127.0.0.1:$LONG_PHP_PORT:9000"

  # Make sure we can communicate with the db container.
  local link="$link --link $db:$db"

  # We need to add an /etc/hosts entry for the host so that esmtp-run 
  # can relay email via the host (it's configured in the container in
  # /etc/esmtprc).
  local ip=$(ip addr show dev docker0 | grep "inet " | awk '{print $2}' | cut -d/ -f1)
  
  # Docker
  docker create --name "$name" \
    --add-host "dockerhost:$ip" \
    -v "${LONG_SRV}/platforms/${platform}:/var/www/powerbase" \
    -v "${dir}/drupal:/var/www/powerbase/sites/default" \
    -v "${LONG_SHARE}/drush:/var/www/.drush" \
    -e "PB_URL=${name}.${LONG_DEFAULT_DOMAIN}" \
    $LONG_MEMORY_LIMIT \
    $link \
    $publish \
    ptp-powerbase:latest php5-fpm 
}

long_create_container() {
  local type="$1"
  local name="$2"
  local db="$3"
  local platform="$4"

  if [ -z "$name" ]; then
    if [ "$type" = "phpmyadmin" ]; then
      name="$type"
    else
      long_die "Containers of this type (%s) need a name passed as second argument." 1 "$type"
    fi
  fi

  # Delete the container if force is specified.
  if [ "$LONG_FORCE" = 1 ]; then
    # If the container is running, that is an error. This command won't
    # start a container after creating it, so we shouldn't stop a container
    # either.
    if long_container_running "$name"; then
      long_die "The container %s is running. Please stop it first."
    fi
    docker rm "$name"
  fi

  # NOTE: These functions not only create the docker containers, but also
  # do a number of indempotent prepration steps. These steps should be
  # taken even if the container already exists, so we wait on the check to see
  # if the container exists until the last docker create statement in each
  # specific container_create function.
  

  # Create a mysql container.
  if [ "$type" = "mysql" ]; then
    long_create_mysql_container "$name"
  elif [ "$type" = "phpmyadmin" ]; then
    long_create_phpmyadmin_container 
  elif [ "$type" = "site" ]; then
    if [ -z "$db" ]; then
      db="$LONG_DEFAULT_DB"
    fi
    if [ -z "$platform" ]; then
      platform="$LONG_DEFAULT_PLATFORM"
    fi
    long_create_site_container "$site" "$db" "$platform" 
  else
    long_die "I don't know how to make a container of that type (%s)." 1 "$type"
  fi
}

long_get_platform_for_site() {
  local site="$1"
  # .HostConfig.Binds shows which volumes are mounted from the host. The
  # first one listed should always be the platform. It will return the 
  # full path to the platform - so we use basename to reduce it to just
  # the platform name.
  LONG_PLATFORM=$(basename $(docker inspect -f '{{.HostConfig.Binds}}' "$site" | egrep -o "/srv/longshore/platforms/ourpowerbase-[a-z0-9.-]*"))
}

long_get_db_for_site() {
  local site="$1"
  LONG_DB_HOST=$(docker inspect -f '{{.HostConfig.Links}}' "$site"| cut -d: -f1 | tr -d '[/')
}

# Install drupal from scratch.
long_install_drupal() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}"

  long_get_platform_for_site "$site"

  # Copy default settings file into place.
  local default_settings_source="${LONG_SRV}/platforms/${LONG_PLATFORM}/sites/default/default.settings.php"
  cp "$default_settings_source" "${dir}/drupal/"

  # Grant the longshore-php group write access to the container to it can
  # create the settings.php file (the longshore-php user should already
  # have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  # Retrieve the password and db host.
  local password=$(grep password "${dir}/my.cnf" | cut -d= -f2)
  long_get_db_for_site "$site"

  if [ -z "$LONG_DB_HOST" ] || [ "$LONG_DB_HOST" = "<no value>" ]; then
    long_die "This site (%s) has no database configured. You should probably re-create it." 1 "$site"
  fi

  # Creating a php file to be executed in the container. This approach
  # avoids sending passwords via the command line.
  local install_file=$(mktemp "${LONG_SITE_TMP}/install.XXXXXXX.php");
cat << EOF > "$install_file"
  <?php
  drush_set_option('account-pass', '$password');
  drush_set_option('account-name', 'admin');
  drush_set_option('site-name', '$site');
  drush_set_option('site-mail', 'info@progressivetech.org');
  drush_set_option('account-mail', 'info@progressivetech.org');
  drush_set_option('db-url', 'mysql://${site}:${password}@${LONG_DB_HOST}/${site}');
  drush_core_pre_site_install();
  drush_core_site_install(NULL);
EOF

  # Ensure that the www-data user can read it.
  chmod 644 "$install_file"

  # Translate file path to work in container.
  c_install_file="/var/www/powerbase/sites/default/private/temp/$(basename $install_file)"

  long_exec_drush_cmd "$site" "-q -y php-script '$c_install_file'"

  # Cleanup
  rm "$install_file"

  # Reset permissions. 
  # Regain ownership of the settings.php file.
  sudo chown longshore "${dir}/drupal/settings.php"

  # And restrict access.
  chmod 0640 "${dir}/drupal/settings.php"

  # Also re-restrict group access to the enclosing directory.
  chmod 755 "${dir}/drupal"
}

# Assuming we have a functional drupal, install CiviCRM
long_install_civicrm() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}"

  # Grant the longshore-php group write access to the container can
  # create the settings.php file (the longshore-php user should already
  # have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  # Create the file to be executed. We can't simply run drush -y civicrm-install
  # because civicrm module is not yet enabled which means civicrm.drush.inc commands
  # are not available to us, so we use a helper command in lsd.
  long_get_base_url_for_site "$site"
  long_exec_drush_cmd "$site" "-q -y lsd-civicrm-install --base_url='$LONG_BASE_URL'"

  # Reset permissions. 
  # Regain ownership of the settings.php file.
  sudo chown longshore "${dir}/drupal/civicrm.settings.php"

  # And restrict access.
  chmod 0640 "${dir}/drupal/civicrm.settings.php"

  # Also re-restrict group access to the enclosing directory.
  chmod 755 "${dir}/drupal"
}

long_import_backup() {
  local site="$1"
  local path="$2"

  if [ -z "$path" ]; then
    path="${LONG_SRV}/services/sites/${site}/backup/${site}.sql.gz"
  fi
  long_execute_site_query "$site" "$path"
}

# Drop all tables in a database. Useful when importing a backup over an existing
# database to ensure no stale temp tables or other tables are left around
long_drop_tables() {
  local site="$1"

  get_tables_temp=$(mktemp)
  drop_tables_temp=$(mktemp)
  echo "SHOW TABLES;" > "$get_tables_temp"
  # The drupal blocked_ips table is needed for the drush command sql-query to
  # function properly.
  for table in $(long_execute_site_query "$site" "$get_tables_temp" \
    | grep -v ^Tables_in | grep -v ^blocked_ips); do
    printf "$table\n"
    entity=TABLE
    if echo "$table" | grep ^civicrm_view > /dev/null; then
      entity=VIEW
    fi
    printf "SET FOREIGN_KEY_CHECKS=0; DROP %s %s;\n" "$entity" "$table" >> "$drop_tables_temp"
  done
  # Only run if we have a drop file that is more than 0 bytes (i.e. 
  # don't run if there are no tables in the database)
  if [ -s "$drop_tables_temp" ]; then
    long_prompt "Deleting all the tables listed above"
    if [ "$reply" = "y" ]; then
      long_log "Deleting the tables" info
      long_execute_site_query "$site" "$drop_tables_temp"
    else
      long_log "Not deleting the tables" info
    fi
  fi
  rm "$get_tables_temp"
  rm "$drop_tables_temp"
}

# Once the site is created, this function ensures that both Drupal and
# CiviCRM are minimally functional and email delivery is ready to go.
long_setup_site() {
  local site="$1"

  if ! long_container_running "$site"; then
    long_die "The container is not running. Please start it first." 
  fi
  
  # Populate the $LONG_SITE_TMP_VAR variable which is used to execute
  # commands in the container.
  long_init_site_tmp_var "$site"

  # Ensure database and settings files are properly installed.
  long_install_site "$site"

  # Ensure all basic drupal and civicrm paths and urls are set. 
  long_exec_drush_cmd "$site" "lsd-set-paths"

  # Ensure the esmtprc is properly configured to forward email to the
  # right host (the dockerhost on live sites, e.g. dockerhost:25, which is
  # configured by default) and the dockerhost:2525 on dev sites, which expects
  # the dev host to be running the mail container.
  if [ "$LONG_LIVE" = "n" ]; then
    docker exec -i -t "$site" /bin/sed -i 's/^hostname=dockerhost:25$/hostname=dockerhost:2525/' \
      /etc/esmtprc
  fi

}

# Once the site is setup, ensure that it is configured in the PTP/PowerBase
# way.
long_configure_site() {
  local site="$1"

  # Populate the $LONG_SITE_TMP_VAR variable which is used to execute
  # commands in the container.
  long_init_site_tmp_var "$site"

  # Set PTP configurations. 
  long_exec_drush_cmd "$site" "ptp-configure"

  long_configure_imap "$site"

  long_exec_drush_cmd "$site" "-y pbd-configure"
}

# Ensure there are the required IMAP users installed on the IMAP server
# and the site is configured properly to connect to the server.
long_configure_imap() {
  local site="$1"

  # We have to create a user with -activities appended to it, and the total
  # length can't exceed 32 characters, so limit usernames to the first
  # 21 characters (-activities is 11, 21 + 11 = 32).
  local imap_base_user=$(echo ${site:0:21})
  local user=

  for user in ${imap_base_user}-activities ${imap_base_user}-returns; do
    long_log "Checking IMAP user '%s'" info "$user"
    # Check if user already exists on the host.
    if ! $LONG_MANAGE_IMAP_USER_CMD exists "$user"; then
      long_log "IMAP user '%s' doesn't exist, adding." info "$user"
      # Create the user
      $LONG_MANAGE_IMAP_USER_CMD add "$user"
      # Set the password.
      pass=$($LONG_MANAGE_IMAP_USER_CMD passwd "$user" 2>/dev/null)
      if [ -z "$pass" ]; then
        long_die "Failed to get password for IMAP user '%s'" 1 "$user"
      fi
      # Configure user and password in CiviCRM, ensuring we don't pass
      # the password exposed via the command line.
      long_configure_civicrm_imap_user "$site" "$user" "$pass"
    fi
  done
}

# Configure the given IMAP user and password in CiviCRM without passing
# password via the command line.
long_configure_civicrm_imap_user() {
  local site="$1"
  local user="$2"
  local pass="$3"

  # Creating a php file to be executed in the container. This approach
  # avoids sending passwords via the command line.
  local imap_file=$(mktemp "${LONG_SITE_TMP}/imap.XXXXXXX.php");
cat << EOF > "$imap_file"
  <?php
  ptp_configure_imap_user($user, $pass, $LONG_IMAP_HOST);
EOF

  # Ensure that the www-data user can read it.
  chmod 644 "$imap_file"

  # Translate file path to work in container.
  c_imap_file="/var/www/powerbase/sites/default/private/temp/$(basename $imap_file)"
  long_exec_drush_cmd "$site" "-q -y php-script '$c_imap_file'"

  # Cleanup
  rm "$imap_file"

}

# Ensure we have a Drupal and CiviCRM database installed and the settings.php
# files properly setup.
long_install_site() {
  local site="$1"

  # Check for settings.php. If it exists, we assume drupal is properly
  # installed. NOTE: if you delete an existing settings.php file you will cause
  # the database to be re-created. If it doesn't exist, we either import from
  # backup or do a fresh instal.
  local dir="${LONG_SRV}/services/sites/${site}"
  local drupal="${dir}/drupal"
  local drupal_settings="${drupal}/settings.php"
  local civicrm_settings="${drupal}/civicrm.settings.php"

  if [ ! -f "$drupal_settings" ]; then
    long_log "No drupal settings.php file is present." info
    # Make sure we have a password - that should be set by the site-create command.
    if [ ! -s "${dir}/my.cnf" ]; then
      long_die "No settings.php file and no my.cnf - I can't setup the site."
    fi

    # Check for a database backup.
    if [ ! -s "${dir}/backup/${site}.sql.gz" ]; then
      # There is no database to restore. We need to do a standard Drupal
      # installation.
      long_log "No backup database. Installing Drupal." info
      long_prompt "Installing Drupal/CiviCRM from scratch. Any existing DB will be destroyed"
      if [ "$reply" != "y" ]; then
        long_log "Not continuing, as directed."
        return
      fi
      long_install_drupal "$site"
      long_log "Installing CiviCRM." info
      long_install_civicrm "$site"
    else
      # We have a backup file. That means we only need to create a drupal
      # settings.php file and import the database. 
      long_log "Importing database from backup." info
      long_prompt "Importing database, any existing DB will be destroyed"
      if [ "$reply" != "y" ]; then
        long_log "Not continuing, as directed."
        return
      fi
      long_get_db_for_site "$site"
      if [ -z "$LONG_DB_HOST" ] || [ "$LONG_DB_HOST" = "<no value>" ]; then
        long_die "This site (%s) has no database configured. You should probably re-create it." 1 "$site"
      fi
      long_create_drupal_settings "$site" "$LONG_DB_HOST"
      long_import_backup "$site"
    fi
  fi
  if [ ! -f "$civicrm_settings" ]; then
    # At this point, we expect to have a working Drupal installation.
    # The only reason there might not be a civicrm file is if we imported
    # our database.
    long_create_civicrm_settings "$site"
  fi
}

# Delete a site container and all related containers and data
long_destroy_site() {
  site="$1"
  
  # Remove the nginx file first so the site is no longer accessible.
  long_log "Disabling nginx configuration." info
  rm -f "${LONG_NGINX_SITES_ENABLED}/${site}.conf"
  long_nginx_reload

  if long_container_running "$site"; then
    long_log "Stopping container." info
    docker stop "$site"
  fi

  # Kill the database.
  long_get_db_for_site "$site"

  # If no database is configured, this is not an error, just continue.
  if [ -n "$LONG_DB_HOST" ] && [ "$LONG_DB_HOST" != "<no value>" ]; then
    temp=$(mktemp)
    echo "DROP DATABASE IF EXISTS \`$site\`" > "$temp"
    long_log "Dropping database (%s) on host (%s)." info "$site" "$LONG_DB_HOST"
    long_execute_root_query "$LONG_DB_HOST" "$temp"  
    rm "$temp"
  fi

  long_log "Deleting container" info
  if long_container_exists "$site"; then
    docker rm "$site"
  fi

  # Delete the data directory.
  long_log "Removing data directory" info
  if [ -d "${LONG_SRV}/services/sites/${site}" ]; then
    # Some files and directories may be owned by longshore-php, so reclaim
    # onwership first.
    sudo chown -R longshore "${LONG_SRV}/services/sites/${site}/drupal/files"
    sudo chown -R longshore "${LONG_SRV}/services/sites/${site}/drupal/private"
    rm -rf "${LONG_SRV}/services/sites/${site}"
  fi

  # Kill the IMAP user on the remote or local host.
  $LONG_MANAGE_IMAP_USER_CMD delete "${user}-activities" 2>/dev/null
  $LONG_MANAGE_IMAP_USER_CMD delete "${user}-returns" 2>/dev/null
}

# Access the given site's database via mysql cli
long_enter_site_database() {
  local site="$1"
  local mycnf="${LONG_SRV}/services/sites/${site}/my.cnf"
  if [ ! -f "$mycnf" ]; then
    long_die "Can't find site my.cnf file (%s)" 1 "$mycnf"
  fi
  mysql --defaults-file="$mycnf"
}

# Download the database from a live aegir site. Once we get off aegir this should be
# removed.
long_download_aegir_db() {
  local site="$1"
  local frontend="$2"
  local live_frontend_login="aegir@${frontend}.mayfirst.org"
  local fqdn="${site}.ourpowerbase.net"
  local temp=$(mktemp -u)
  local local_sql_dump="${LONG_SRV}/services/sites/${site}/backup/${site}.sql.gz"
  
  path="/var/aegir/backups/${fqdn}.daily.tar.gz"
  long_log "Extracting database on %s" "$live_frontend_login"
  ssh "$live_frontend_login" "ionice -c2 -n7 tar --extract --to-stdout --file '$path' ./database.sql > '$temp'"

  long_log "gzip'ing dump" info
  ssh "$live_frontend_login" "gzip '$temp'"

  long_log "Copying sql dump to %s" info "${local_sql_dump}"
  scp "$live_frontend_login":"${temp}.gz" "${local_sql_dump}"

  long_log "Removing dump from live server" info
  ssh "$live_frontend_login" "rm '${temp}.gz'"
}

long_fetch_site() {
  local site="$1"
  long_log "Getting remote path and server" info
  local user=aegir
  local default_frontend=nicolas

  local live_info=$(ssh ${user}@${default_frontend}.mayfirst.org "ptp-get-frontend-for-site '$site' && ptp-get-path '$site'")
  local frontend=$(echo "$live_info" | head -n1)
  local path=$(echo "$live_info" | tail -n -1)

  if [ -z "$frontend" -o -z "$path" ]; then
    long_die "Can't find front end or path" 
  fi

  local source_base="${user}@${frontend}.mayfirst.org:$path"
  local target_base=${LONG_SRV}/services/sites/${site}/drupal

  long_prompt "\nSource: %s\ntarget: %s\n" "$source_base" "$target_base"

  if [ "$reply" != "y" ]; then
    long_die "Not continuing."
  fi

  # Build out the directory structure
  long_create_site_directories "$site"

  # Copy over modules and themes

  # We don't want to bring over owner/perms to facilitate setting perms
  # properly in the site-create stage.

  long_log "Sync'ing code and templates" info

  rsync -a --no-owner --no-perms --delete \
    "${source_base}/modules/" "${target_base}/modules/"
  rsync -a --no-owner --no-perms --delete \
    "${source_base}/themes/" "${target_base}/themes/"
  rsync -a --no-owner --no-perms --delete \
    "${source_base}/custom-civicrm/php/" "${target_base}/custom-civicrm/php/"
  rsync -a --no-owner --no-perms --delete \
    "${source_base}/custom-civicrm/templates/" "${target_base}/custom-civicrm/templates/"

  # Now get files.

  # First we have to chown so we can rsync. After building out the directories,
  # these directories will be owned by longshore-php, not longshore.
  sudo chown -R longshore "${target_base}/files"
  sudo chown -R longshore "${target_base}/private"

  # Rsync

  # Clear the js, css and template caches
  rm -rf "${target_base}"/files/js/*
  rm -rf "${target_base}"/files/css/*
  rm -rf "${target_base}"/files/civicrm/templates_c/*

  long_log "Sync'ing files" info

  rsync -a --no-owner --no-perms --delete --exclude 'js/*' \
    --exclude 'css/*' --exclude 'civicrm/templates_c/*' \
    --exclude 'civicrm/ConfigAndLog/*' \
    "${source_base}/files/" "${target_base}/files/"
  rsync -a --no-owner --no-perms --delete \
    "${source_base}/private/" "${target_base}/private/"

  long_download_aegir_db "$site" "$frontend"
}

long_set_sites() {
  local frontend="$1"

  # frontend is not yet implemented...
  LONG_SITES=$(ls "${LONG_SRV}/services/sites")
}

long_create_dns() {
  local site="$1"
  local api_login=pb-api-user
  local url="https://members.mayfirst.org/cp/api.php"
  local fqdn="${site}.${LONG_DOMAIN}"
  local hosting_order_id=1000002
  local service_id=9
  local dns_ttl=600
  local red_api_password_path="~/.red-api-password"
  local api_password=$([ -s "$red_api_password" ] && cat "$red_api_password_path")

  # Sanity checking.
  if [ "$LONG_LIVE" != "y" ]; then
    # Don't die, this isn't a fatal error.
    long_log "Not setting DNS in dev instance." info
    return
  fi
  exists=$(dig +short @a.ns.mayfirst.org "$fqdn")
  if [ "$?" != 0 ]; then
    long_die "Error checking dns. Output: %s" 1 "$exists"
  fi
  if [ -n "$exists" ]; then
    long_log "The DNS has already been created, it is %s." info "$exists"
    return
  fi
  [ -z "$api_password" ] && long_die "Please put your red api password in %s." 1 "$red_api_password_path"
  [ -z "$LONG_IP_ADDR" ] && long_die "The host IP address is not set in longshore.conf"

  
  post="action=insert&output=text&object=item&set:service_id=${service_id}&set:hosting_order_id=${hosting_order_id}&set:dns_fqdn=${fqdn}&set:dns_type=a&set:dns_ttl=${dns_ttl}&set:dns_ip=${LONG_IP_ADDR}&user_name=$api_login&user_pass=$api_password&output_format=text"

  out=$(wget -q --post-data="$post" -O- "$url")

  if [ "$?" -ne "0" ]; then
    long_die "Failed to use wget when setting the DNS entry."
  fi

  echo "$out" | grep '"is_error":0' > /dev/null

  if [ "$?" -ne "0" ]; then
    echo "$out"
    long_die "Failed to create DNS record."
  fi
}

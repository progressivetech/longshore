# This file should be sourced by all scripts. It contains
# shared functions

# Variables that can be set via the environment are:
# LONG_DRUSH_ARGS - to pass arbitrary args to all drush invocations,
#   such as --debug or -v
# LONG_YES - to bypass any prompts that this libraries handles
#   (that does not include drush prompts, so you may need to 
#   combine with LONG_DRUSH_ARGS=-y if you want to fully automate
#   a script).

# One liner for printing message and dying
# long_die $msg $exit_code $var $var
long_die() {
  local msg="$1"
  local exit_code="$2"
  shift 2
  [ -z "$exit_code" ] && exit_code=1
  long_log "$msg" error "$@"
  exit "$exit_code"
}

# Return defined $long_usage_message and die 
long_usage() {
  local exit_code="$1"
  [ -z "$exit_code" ] && exit_code=1
  long_die "$long_usage_message" "$exit_code"
}

# Ensure the number of required arguments have been passed
# and if not, run long_usage (which will exit). Also, parse
# global arguments (like -f for force).
long_check_args() {
  # The sub command is one argument that we don't count, so subtract 1 from 
  # the number of arguments passed.
  local first_arg="$1"
  local num_passed=$(( $2 - 1 ))
  local num_required="$3"
  [ -z "$num_passed" ] && num_passed=0
  [ -z "$num_required" ] && num_required=0
  if [ "$first_arg" = "-h" ] || [ "$first_arg" = "--help" ]; then
    long_usage  
  fi 
  if [ "$num_passed" -lt "$num_required" ] ; then
    long_log "Not enough arguments passed. Expecting at least %s, received %s.\n" \
      error "$num_required" "$num_passed"
    long_usage
  fi
}

# Prompt the user but don't allow LONG_YES to override the prompt.
# See long_prompt() for syntax.
long_always_prompt() {
  local prompt_msg="$1"
  shift

  # Override LONG_YES
  local orig_long_yes="$LONG_YES"
  LONG_YES=0

  # Prompt user
  long_prompt "$prompt_msg" "$@"

  # Reset LONG_YES
  LONG_YES="$orig_long_yes"
}

# Prompt the user with a given message ($1) and the question
# "Proceed? [Yn]" - set $reply variable to either y or n, properly
# parsing case and the default.
long_prompt() {
  local prompt_msg=$1
  shift
  printf "${prompt_msg}\n" "$@"
  if [ "$LONG_YES" = "1" ]; then
    printf " Automatically proceeding without prompt.\n"
    # reply is a global - exception to the rule of all capitals and 
    # LONG prefix.
    reply=y
    return
  fi
  read -p "Proceed? [Yn] "
  reply=n
  if [ -z "$REPLY" ] || [ "$REPLY" == "Y" ] || [ "$REPLY" == "y" ]; then
    reply=y
  fi
}

# Either output a message to standard error or send it by email
# depending on whether we are running from a cron job or not
long_debug() {
  local debug_msg="$1"
  local debug_subject="$2"
  if [ -z "$PS1" ]; then
    echo "$debug_msg" | mail -s "$debug_subject" "$LONG_WARNING_EMAIL"
  else
    echo "$debug_subject" >&2
    echo "$deubg_msg" >&2
  fi
}

# Check if a conatiner with the given name exists or not.
# Return 0 if it exists and 1 if it doesn't.
long_container_exists() {
  long_container_or_image_exists "$1"
}

# Inspect seems to work for both containers and images.
long_container_or_image_exists() {
  local name="$1"
  [ -z "$name" ] && return 1
  # This command returns 1 if the container doesn't exist and 0 if it does.
  docker $LONG_DOCKER_LOG_ARG inspect "$name" 2>/dev/null 1>/dev/null
  return "$?"
}

# Check if a container with the given name is running or not.
# Return 0 if it is running and 1 if it isn't.
long_container_running() {
  local name="$1"
  [ -z "$name" ] && return 1

  if [ "$name" = "mysqlhost" ];then
    return 0
  fi

  container_running=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.State.Running}} "$name")
  [ "$container_running" = "true" ] && return 0
  return 1
}

# Check if an image with the given name exists.
# Return 0 if it exists and 1 if it doesn't.
long_image_exists() {
  long_container_or_image_exists "$1"
}

# Generate a my.cnf file with the given info
long_generate_my_cnf() {
  local dir="$1"
  local password="$2"
  local port="$3"
  local user="$4"
  local db="$5"

  [ ! -d "$dir" ] && long_die "Can't generate my.cnf. Directory (%s) doesn't exist." 1 "$dir"

  [ -z "$user" ] && user=root

  printf "[client]\nuser=%s\npassword=%s\nport=%s\nhost=127.0.0.1\n" \
    "$user" "$password" "$port" > \
    "$dir"/my.cnf

  # If this is a site my.cnf file, add the database name.
  if [ "$user" != "root" ]; then
    printf "[mysql]\ndatabase=%s\n" "$db" >> "$dir"/my.cnf
  fi
}

# Generate a random password
long_pwgen() {
  size="$1"

  if [ -z "$size" ]; then
    size=25
  fi
  # Excluding characters that commonly cause problems. Sigh.
  LONG_PASSWORD=$(hexdump -e '"%_p"' /dev/urandom | tr -d '[:punct:] \n' | head -c "$size")
}

# Output logging info based on log level
# long_log $msg $log_level $var $var
# log levels: info, error, critical
long_log() {
  local log_msg="$1"
  local log_level="$2"
  if [ -z "$log_level" ]; then
    log_level=info
  fi
  shift 2
  local log_out=n
  # Always output critical
  if [ "$log_level" = "critical" ]; then
    log_out=y
  fi
  # Output error if we are set to info or error
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "info" ];  then
    log_out=y
  fi
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "error" ];  then
    log_out=y
  fi
  # Output info if we are set to info
  if [ "$log_level" = "info" -a "$LONG_LOG_LEVEL" = "info" ];  then
    log_out=y
  fi
  if [ "$log_out" = "y" ]; then
    printf "$log_msg\n" "$@"
  fi
  # Always log to syslog
  printf "$log_msg" "$@" | logger -t longshore
}

# Save the generic tls configuration for all sites
long_create_nginx_tls_conf() {
  local template="${LONG_SHARE}/templates/nginx-tls.conf"
  local target="$LONG_NGINX_TLS_PATH"
  cat "$template" | \
    sed \
    -e "s:LONG_TLS_KEY_PATH:$LONG_TLS_KEY_PATH:" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    -e "s:LONG_X509_CERT_PATH:$LONG_X509_CERT_PATH:" \
    -e "s:LONG_DH_PARAM_PATH:$LONG_DH_PARAM_PATH:" \
    > "$target"
}

# save the phpmyadmin nginx configuration file
long_create_nginx_phpmyadmin_conf() {
  local port="$1"
  local template="${LONG_SHARE}/templates/nginx-phpmyadmin.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/phpmyadmin.conf"
  LONG_SITE_URL="$LONG_PHPMYADMIN_URL"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    local tls_or_not="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect phpmyadmin "$LONG_SITE_URL"
  else
    local tls_or_not="listen ${LONG_IP_ADDR}:80;"
  fi
  LONG_CGI_PORT="$port"
  cat "$template" | \
    sed \
    -e "s#LONG_TLS_OR_NOT#$tls_or_not#" \
    -e "s:LONG_SITE_URL:$LONG_SITE_URL:" \
    -e "s:LONG_CGI_PORT:$LONG_CGI_PORT:" \
    > "$target"
}

# Pass the short site name as first argument and the full
# URL as the second.
long_create_nginx_redirect() {
  local site="$1"
  local site_url="$2"
  local aliases="$3"

  local template="${LONG_SHARE}/templates/nginx-redirect-https.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/${site}-redirect.conf"
  cat "$template" | \
    sed \
    -e "s#LONG_SITE_URL#$site_url#" \
    -e "s#LONG_ALIASES#$aliases#" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    > "$target"
}

# Save an nginx server configuration file
long_create_nginx_site_conf() {
  local site="$1"
  local platform="$2"
  local port="$3"
  local aliases="$4"

  local template="${LONG_SHARE}/templates/nginx-site.conf"
  local target="${LONG_NGINX_SITES_ENABLED}/${site}.conf"
  local long_site_url="${site}.${LONG_DEFAULT_DOMAIN}"

  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    local tls_or_not="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect "$site" "$long_site_url" "$aliases"
  else
    local tls_or_not="listen ${LONG_IP_ADDR}:80;"
  fi
  local LONG_ACCESS_LOG="${site}.access.log"
  local LONG_WEB_ROOT="/var/www/powerbase/${platform}"
  local LONG_PHP_ROOT="/var/www/powerbase"
  local LONG_CGI_PORT="$port"

  cat "$template" | \
    sed \
    -e "s#LONG_TLS_OR_NOT#$tls_or_not#" \
    -e "s#LONG_ACCESS_LOG#$LONG_ACCESS_LOG#" \
    -e "s#LONG_SITE_URL#$long_site_url#" \
    -e "s#LONG_ALIASES#$aliases#" \
    -e "s#LONG_WEB_ROOT#$LONG_WEB_ROOT#" \
    -e "s#LONG_PHP_ROOT#$LONG_PHP_ROOT#" \
    -e "s#LONG_CGI_PORT#$LONG_CGI_PORT#" \
    -e "s#LONG_SITE#$site#" \
    > "$target"
}

# Return 0 if it's the latest and 1 if it's not and 2 for an error.
long_phpmyadmin_is_latest() {
  # Check version installed
  local installed=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/README" ]; then
    installed=$(head "${LONG_SRV}/services/phpmyadmin/src/README" | grep '^Version' | cut -d\  -f2)
  else
    # It's not installed at all, that means not the latest.
    return 1 
  fi

  [ -z "$installed" ] && return 2 

  local latest=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/version_check.php" ]; then
    latest=$(cd "${LONG_SRV}/services/phpmyadmin/src/" && php version_check.php | tr -d '{}"' | cut -d, -f1 | cut -d: -f2)
  else
    # Something is broken if we don't have this file
    return 2 
  fi

  [ -z "$latest" ] && return 2 

  [ "$latest" = "$installed" ]  && return 0
  return 1
}

# This variable containing the names of all database containers
long_set_db_containers() {
  LONG_DB_CONTAINERS=$(ls "${LONG_SRV}/services/databases/" | grep -v "lost+found")
}

# Create if necessary the given image
# first argument is tag, second is path to docker directory
long_create_image() {
  local image_tag="$1"
  local image_path="$2"

  # If image_page is left out, auto-calculate it
  if [ -z "$image_path" ]; then
    if [ "$image_tag" = "ptp-mysql" ]; then
      image_path="${LONG_ETC}/dockerfiles/mysql"
    elif [ "$image_tag" = "ptp-php" ]; then
      image_path="${LONG_ETC}/dockerfiles/php"
    elif [ "$image_tag" = "ptp-powerbase" ]; then
      image_path="${LONG_ETC}/dockerfiles/powerbase"
    elif [ "$image_tag" = "my-${LONG_DEBIAN_VERSION}" ]; then
      image_path=""
    else
      long_die "I don't know how to make an image of that type (%s)." 1 "$itype"
    fi
  fi

  # By default don't create the image
  local create_image=0
  if ! long_image_exists "$image_tag"; then
    # Image doesn't exist, we should create it.
    create_image=1
  fi

  if [ "$create_image" -eq "1" -o "$LONG_FORCE" = "1" ]; then
    long_log "Creating image (%s)" info "$image_tag"
    if [ "$image_tag" = "my-${LONG_DEBIAN_VERSION}" ]; then
      # If the image name begins with "my-" (e.g. my-stretch), then
      # this is a special condition
      long_create_base_image
    else
      # If we are forcing the image to be re-created, then we should not
      # use the cache.
      cache=
      if [ "$LONG_FORCE" = "1" ]; then
        cache="--no-cache"
      fi

      # This sub-command seems to ignore the -l error flag.
      if [ "$LONG_LOG_LEVEL" = "error" ]; then
        docker build -t "$image_tag" "$cache" "$image_path" >/dev/null
      else
        docker build -t "$image_tag" "$cache" "$image_path"
      fi
    fi
  fi
}

# Create the base image
long_create_base_image() {
  long_log "Creating base image" info
  # Adjust output based on LONG_LOG_LEVEL
  if [ "$LONG_LOG_LEVEL" = "error" ]; then 
    sudo ${LONG_SRV}/bin/longshore-create-base-image >/dev/null
  else
    sudo ${LONG_SRV}/bin/longshore-create-base-image
  fi
}

# Delete, if necessary, the image
long_delete_image() {
  local tag="$1"
  if long_image_exists "$tag"; then
    long_log "Deleting  image (%s)" info "$tag"
    docker $LONG_DOCKER_LOG_ARG rmi "$tag"
  fi
}

# Create (if necessary) and start (if necessary) a given container
long_container_up() {
  local type="$1"
  local name="$2"
  local db="$3"
  local platform="$4"

  if [ "$type" = "mysql" -a "$name" = "mysqlhost" ]; then
    # mysqlhost mysql server should always be running.
    return
  fi

  # phpmyadmin will be called with just the type variable set.
  # In these cases, we use the type as the name - since we only have one
  # one phpmyadmin container.
  local label="$name"
  [ -z "$label" ] && label="$type"

  # long_create_container will check if it exists first and respect MF_FORCE.
  long_create_container "$type" "$name" "$db" "$platform"

  if ! long_container_running "$label"; then
    long_log "Starting container (%s)" info "$label"
    if [ "$type" = "site"  -a "$db" != "mysqlhost" ]; then
      # Ensure db container is running first.
      long_set_site_db_host "$name"
      long_container_up mysql "$LONG_SITE_DB_HOST"
    fi

    # Start the container.
    docker $LONG_DOCKER_LOG_ARG start "$label" || long_die "Failed to start the container %s" 1 "$label"

    if [ "$type" = "mysql" ]; then
      # When starting mysql containers, wait 30 seconds and then ensure 
      # the databases are upgraded.
      while ! long_up_long_enough "$name" 60; do
        long_log "Waiting 10 more seconds to ensure database has started." info
        sleep 10 
      done
      long_log "Running mysql_upgrade."
      docker $LONG_DOCKER_LOG_ARG exec "$name" mysql_upgrade -h localhost --port 3306
      long_log "Finished running mysql_upgrade."
    fi
  fi
}

# Reload nginx to pickup new configurations
long_nginx_reload() {
  sudo /etc/init.d/nginx reload > /dev/null
}

# Get the port for this mysql container, or assign a new one.
long_set_mysql_port() {
  local name="$1"

  if [ "$name" == "mysqlhost" ]; then
    LONG_DB_PORT=3306
    return
  fi

  local dir="${LONG_SRV}/services/databases/${name}"
  local last_port=
  if [ -f "$dir/my.cnf" ]; then
    LONG_DB_PORT=$(grep port "${dir}/my.cnf" | cut -d= -f2)
  else
    # If we don't already have a .my.cnf file, find the next available port.
    last_port=$(grep port= "${LONG_SRV}"/services/databases/*/my.cnf 2>/dev/null | cut -d= -f2 | sort -n | tail -n 1)
    if [ -z "$last_port" ]; then
      LONG_DB_PORT="$LONG_MYSQL_START_PORT"
    else
      LONG_DB_PORT=$(( $last_port + 1 ))
    fi
  fi
}

# Get the port for this php container, or assign a new one.
long_set_php_port() {
  local name="$1"
  local envdir=
  local last_port=
  local port_candidate=

  if [ "$name" = "phpmyadmin" ]; then
    envdir="${LONG_SRV}/services/phpmyadmin/env"
  else
    envdir="${LONG_SRV}/services/sites/${name}/env"
  fi

  # Set the global var that will hold the value to empty.
  LONG_PHP_PORT=

  # If the container has been created, we should already have a port.
  if [ -f "${envdir}/PORT" ]; then
    port_candidate=$(cat "${envdir}/PORT")

    # Make sure it is not being used by another site (e.g., we may be transferring
    # this site to another server and the port could be in use).
    if ! docker ps | egrep -v " ${name}\$" | grep "127.0.0.1:$port_candidate" >/dev/null; then
      LONG_PHP_PORT="$port_candidate"
    fi
  fi

  if [ -z "$LONG_PHP_PORT" ]; then
    # If we don't already have a PORT file, find the next available port.
    last_port=$(cat "${LONG_SRV}/services/phpmyadmin/env/PORT" "${LONG_SRV}"/services/sites/*/env/PORT 2>/dev/null | sort -n | tail -n1)
    if [ -z "$last_port" ]; then
      LONG_PHP_PORT="$LONG_PHP_START_PORT"
    else
      LONG_PHP_PORT=$(( $last_port + 1 ))
    fi
  fi
  mkdir -p "$envdir"
  echo "$LONG_PHP_PORT" > "${envdir}/PORT"
}

# Take the passed in var and sanitize for sql statement
long_sql_sanitize_var() {
  LONG_SANE_VAR=$(echo "$1" | sed 's/[^0-9a-z_]//g')
}

# Create a database and database user for the given site, db name
# and password.
long_create_db() {
  local site="$1"
  local dbname="$site"
  local dbuser="$site"
  local dbhost="$2"
  
  # Site names should only have letters, numbers and dashes. However,
  # dashes aren't allowed so replace - with _.
  dbname="${dbname//-/_}" 

  # Just in case, sanitize the resulting dbname.
  long_sql_sanitize_var "$dbname"
  dbname="$LONG_SANE_VAR"

  local temp=$(mktemp)

  # Always ensure database exists. This is easy, idempotent.
  echo "CREATE DATABASE IF NOT EXISTS \`$dbname\`;" > "$temp"

  # Only ensure the user/password exists if we don't have a my.cnf file.
  local dir="${LONG_SRV}/services/sites/${site}"
  local mycnf_file="${dir}/my.cnf"
  if [ ! -f "$mycnf_file" ]; then 
    # Ensure we don't have usernames longer than 16 characters.
    long_sanitize_db_username "$dbuser"
    dbuser="$LONG_DBUSER"

    # Generate random password.
    long_log "Generating database password." info
    long_pwgen
    echo "GRANT ALL ON \`$dbname\`.* TO '$dbuser'@'%' IDENTIFIED BY '$LONG_PASSWORD';" >> "$temp"

    # Get the LONG_DB_PORT for this database host.
    long_set_mysql_port "$dbhost"
    long_generate_my_cnf "$dir" "$LONG_PASSWORD" "$LONG_DB_PORT" "$dbuser" "$dbname"
  fi

  if [ "$dbhost" != "mysqlhost" ]; then
    while ! long_up_long_enough "$dbhost" 60; do
      long_log "Waiting 10 more seconds to ensure database has started." info
      sleep 10 
    done
  fi
  long_execute_root_query "$dbhost" "$temp"
  rm "$temp"
}

# Return 0 if the given site has been up more than the specified number of
# seconds. Otherwise 1.  Useful for determining whether we can expect MySQL to
# be ready to receive a sql query.
long_up_long_enough() {
  local site="$1"
  local seconds="$2"
  local site_up_iso=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.State.StartedAt}} "$site")

  # We have to account for a changing time/date format in docker (see
  # https://stackoverflow.com/questions/20979320/convert-iso8601-date-to-epoch-format-unix-timestamp)
  # Version 1.6.2 produces 2015-06-15T18:28:23.399450961Z, which can be passed
  # to `date` and can be parsed with strtotime. However, version 1.7 (and
  # presumably versions after that) pass 2015-06-30 11:57:08.70183993 +0000 UTC
  # which can't be parsed with strtotime.  So, grep for a space and if we find
  # one, then we have to strip the timezone spec off - which works because when
  # converting, we pass --utc to say this is a UTC time we are passing in,
  # which makes the timezone redundant anyway.
  site_up_iso=$(echo "$site_up_iso" | sed 's/ +0000 UTC//')
  local now_ts=$(date '+%s')
  local site_up_ts=$(date --utc --date "$site_up_iso" '+%s')
  local diff=$(( $now_ts - $site_up_ts ))
  if [ "$diff" -gt "$seconds" ]; then
    return 0
  fi
  return 1
}

# Execute the queries in the passed in file on the given database as the
# site's non-privileged user.
long_execute_site_query() {
  local site="$1"
  local file="$2"

  if [ ! -f "$file" ]; then
    long_die "Can't find file with queries to execute."
  fi

  long_set_site_db_host "$site"

  if [ "$LONG_SITE_DB_HOST" != "mysqlhost" ]; then
    # Make sure the db container exists
    long_container_exists "$LONG_SITE_DB_HOST"

    if [ "$?" != 0 ]; then
      long_die "The database container doesn't exist (%s)" 1 "$LONG_SITE_DB_HOST"
    fi

    long_container_running "$LONG_SITE_DB_HOST"
    if [ "$?" != 0 ]; then
      long_die "The database container isn't running (%s)" 1 "$LONG_SITE_DB_HOST"
    fi
  fi

  mycnf="${LONG_SRV}/services/sites/${site}/my.cnf"
  if [ ! -f "$mycnf" ]; then
    long_die "The my.cnf file doesn't exist for this site (%s)" 1 "$mycnf"
  fi
  
  # We should be able to handle gzip or non-gzipped files.
  cmd=cat
  if file -b "$file" | grep "^gzip" >/dev/null; then
    cmd="gunzip -c"
  fi
  # Strip definer statements since we are running as a non-privileged user
  # to avoid "You need SUPER privileges" for this operation..
  $cmd "$file" | sed 's#/\*!5001[37] DEFINER=[^*]*\*/# #g' | mysql --defaults-file="$mycnf"
}

# Execute the queries in the passed in file on the given database as the
# db root user.
long_execute_root_query() {
  local db="$1"
  local file="$2"
  local mycnf

  if [ ! -f "$file" ]; then
    long_die "Can't find file with queries to execute."
  fi

  # "mysqlhost" means use the one central database, not a designated container.
  if [ "$db" == "mysqlhost" ]; then
    mycnf="${LONG_ETC}/my.cnf"
  else
    # Make sure the db container exists
    long_container_exists "$db"

    if [ "$?" != 0 ]; then
      long_die "The database container doesn't exist (%s)" 1 "$db"
    fi

    long_container_running "$db"
    if [ "$?" != 0 ]; then
      long_die "The database container isn't running (%s)" 1 "$db"
    fi

    mycnf="${LONG_SRV}/services/databases/${db}/my.cnf"
  fi

  if [ ! -f "$mycnf" ]; then
    long_die "The my.cnf file doesn't exist for this database (%s)" 1 "$mycnf"
  fi
  
  mysql --defaults-file="$mycnf" < "$file"
}

# Initialize the LONG_SITE_TMP variable. 
long_init_site_tmp_var() {
  local name="$1"
  LONG_SITE_TMP="${LONG_SRV}/services/sites/${name}/drupal/private/temp"
}

# Create a drupal settings.php file.
long_create_drupal_settings() {
  local site="$1"
  local dbhost="$2"

  local dir="${LONG_SRV}/services/sites/${site}"
  local dbpass=$(grep ^password "${dir}/my.cnf" | cut -d= -f2)
  local dbuser=$(grep ^user "${dir}/my.cnf" | cut -d= -f2)
  local dbname=$(grep ^database "${dir}/my.cnf" | cut -d= -f2)
  long_set_site_platform "$site"
  local source="${LONG_SRV}/platforms/${LONG_SITE_PLATFORM}/sites/default/default.settings.php"
  local target="${dir}/drupal/settings.php"

  # Copy the template into place.
  cp "$source" "$target"

  # And then append the database configuration.
  source="${LONG_SHARE}/templates/db.php"
  cat "$source" | \
    sed \
    -e "s:LONG_DB_NAME:$dbname:" \
    -e "s#LONG_DB_USER#$dbuser#" \
    -e "s#LONG_PASSWORD#$dbpass#" \
    -e "s#LONG_SITE_DB_HOST#$dbhost#" \
    >> "$target"
  # Ensure proper permissions
  chmod 0640 "$target"
  sudo chgrp longshore-php "$target"
}

# Give a site, set a variable for the base_url
long_set_site_base_url() {
  site="$1"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    protocol='https://'
  else
    protocol='http://'
  fi

  LONG_SITE_BASE_URL="${protocol}${site}.${LONG_DEFAULT_DOMAIN}"
}

# Given the longshore logging setting, set a variable for
# docker output
long_set_docker_log_arg() {
  if [ "$LONG_LOG" = "error" ]; then
    LONG_DOCKER_LOG_ARG="-l error"
  else
    LONG_DOCKER_LOG_ARG="-l info"
  fi
}

# Create civicrm settings file.
long_create_civicrm_settings() {
  local site="$1"

  # Grant the longshore-php group write access to the container default dir so
  # it can create the civicrm.settings.php file (the longshore-php user should
  # already have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  long_set_site_base_url "$site"
  long_exec_drush_cmd "$site" "lsd-civicrm-settings --base_url='$LONG_SITE_BASE_URL'"

  # Ensure proper permissions
  local target="${LONG_SRV}/services/sites/${site}/drupal/civicrm.settings.php"
  sudo chown "$LONG_HOST_USER" "$target"
  sudo chgrp longshore-php "$target"
  chmod 0640 "$target"

  # Remove write access.
  chmod 755 "${dir}/drupal"
}

# Execute the given drush command in the given container as the www-data user.
long_exec_drush_cmd() {
  local site="$1"
  local cmd="$2"
  local envvars="$3"
  local -i return=0

  # Set drush quiet setting. Default is not to be quiet.
  quiet=-v
  if [ "$LONG_LOG_LEVEL" = "error" ]; then
    # Make drush more quiet.
    quiet=-q
  fi
  long_init_site_tmp_var "$site"
  local file=$(mktemp "${LONG_SITE_TMP}/drupal.XXXXXXX");
  chmod 755 "$file"
  printf "#!/bin/bash\n" > "$file"
  if [ -n "$envvars" ]; then
    for var in $envvars; do
      if [ -n "${!var}" ]; then
        printf "export ${var}=${!var}\n" >> "$file"
      fi
    done
  fi
  printf 'cd /var/www/powerbase/sites/default && ' >> "$file"
  printf "drush $quiet $cmd\n" >> "$file"
  long_exec_in_container "$site" "$file"
  return="$?"
  rm "$file"
  return "$return"
}

# Launch an interactive bash shell in the given site as wwww-data
long_enter_site() {
  local site="$1"
  docker $LONG_DOCKER_LOG_ARG exec -i -t "$site" su -l -s "/bin/bash" www-data
}


# Execute the given command in the given container as www-data. 
long_exec_in_container() {
  local site="$1"
  local cmd="$2"

  long_init_site_tmp_var "$site"
  # If the file to execute is in $LONG_SITE_TMP, then we need to translate
  # the path to where it will exist in the site container.
  local dir=$(dirname "$cmd")
  if [ "$dir" = "$LONG_SITE_TMP" ]; then
    cmd="/var/www/powerbase/sites/default/private/temp/$(basename $cmd)"
  fi
  docker $LONG_DOCKER_LOG_ARG exec "$site" su -l -c "$cmd" www-data
}

# Low lever mysql container creation. Call long_create_container instead
# if possible.
long_create_mysql_container() {
  local name="$1"

  if [ "$name" = "mysqlhost" ]; then
    long_die "Not creating mysqlhost database. Fix this code."
  fi

  if [ -z "$name" ]; then
    long_die "Can't create a db container without a name." 
  fi

  local dir="${LONG_SRV}/services/databases/${name}"
  # Make sure our base directory and a mysql sub directory exists.
  # Our my.cnf file will go in ${dir}/my.cnf and be mounted in the host
  # in /mnt/my.cnf and ${dir}/mysql will get mounted at /var/lib/mysql.
  mkdir -p "${dir}/mysql"
  mkdir -p "${dir}/logs"

  # Each host can optionally allocated a dedicated partition
  # to be used on db containers for /tmp (which is where mysql
  # will write out queries too big to fit in memory). By using
  # a volume for this it is more efficient than writing it via
  # overlay2 and also prevents a disk fill up from impacting
  # other services.
  if [ ! -d "${LONG_SRV}/tmp" ]; then
    long_die "Missing tmp directory: ${LONG_SRV}/tmp."
  fi
  local tmp_volume="${LONG_SRV}/tmp"

  # Get the port number. Each MySQL container is assigned a unique port
  # on the host. This will generate a LONG_DB_PORT variable.
  long_set_mysql_port "$name"

  # Check for existence of my.cnf file and create if necessary.
  if [ ! -f "${dir}/my.cnf" ]; then
    # Use our password generation utility which uses /dev/urandom.
    # long_pwgen will assign a new password to the variable $LONG_PASSWORD.
    long_pwgen

    long_generate_my_cnf "$dir" "$LONG_PASSWORD" "$LONG_DB_PORT"
  fi

  # Bail if the container already exists. 
  if long_container_exists "$name"; then
    return
  fi

  long_log "Creating mysql container (%s)." info "$name"

  docker $LONG_DOCKER_LOG_ARG create --log-driver "$LONG_DEFAULT_LOG_DRIVER" --name "$name" \
    -v "${dir}/mysql:/var/lib/mysql"  \
    -v "${dir}/my.cnf:/root/.my.cnf" \
    -v "${dir}/logs:/var/log/mysql" \
    -v "${tmp_volume}:/tmp" \
    -e "LONG_LIVE=$LONG_LIVE" \
    -e "MYSQL_UID=$UID" \
    -p "127.0.0.1:${LONG_DB_PORT}:3306" \
    --restart unless-stopped \
    $LONG_DOCKER_MEMORY_LIMIT \
    ptp-mysql:latest mysqld || long_die "Failed to create the container %s" 1 "$name"
  # Since db containers are linked to other containers, the other containers
  # will fail to start if the db containers are not started. So, always
  # start after creation.
  #docker start "$name"

  # Lastly, re-create the phpmyadmin container so it can link to the
  # potentially new db container.
  #long_recreate_container phpmyadmin
}

# Low level phpmyadmin container creation. Call long_create_container instead
# if possible.
long_create_phpmyadmin_container() {
  local dir="${LONG_SRV}/services/phpmyadmin"
  # Make sure we have our base directories
  mkdir -p "$dir/src"

  # Create the server.list file with all db servers on this host
  long_set_db_containers
  echo "$LONG_DB_CONTAINERS" > "${dir}/src/servers.list"

  if [ -f "$LONG_ETC/my.cnf" ]; then
    # We need the address of the central db
    echo "$LONG_MYSQL_HOST_IP" >> "${dir}/src/servers.list"
  fi

  # Create the --link argument
  local link=
  for link_db in $LONG_DB_CONTAINERS; do
    link="$link --link $link_db:$link_db"
  done

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  long_set_php_port phpmyadmin

  # The phpmyadmin container has to be available via a local port since 
  # nginx, which is running on localhost, has to communicate with it.
  publish="-p 127.0.0.1:$LONG_PHP_PORT:9000"

  # Copy in the config.inc.php.sample file with blowfish secret
  long_pwgen "50"
  cat ${LONG_SHARE}/templates/phpmyadmin.config.inc.php.sample | sed "s/BLOWFISHSECRET/$LONG_PASSWORD/" \
    > "${dir}/src/config.inc.php" 

  # Create nginx configuration
  long_create_nginx_phpmyadmin_conf "$LONG_PHP_PORT"

  # Bail if the container already exists. 
  if long_container_exists phpmyadmin; then
    return
  fi

  # Docker
  docker $LONG_DOCKER_LOG_ARG create --log-driver "$LONG_DEFAULT_LOG_DRIVER" --name phpmyadmin \
    -v "${dir}/src:/var/www/phpmyadmin" \
    $link \
    $publish \
    -e "LONG_LIVE=$LONG_LIVE" \
    $LONG_DOCKER_MEMORY_LIMIT \
    --restart unless-stopped \
    ptp-php:latest php-fpm7.3  || long_die "Failed to create the phpmyadmin container"
}

# Build out the required directories and permissions
# for a given site. 
long_create_site_directories() {
  local site="$1"
  local perms=
  local dir="${LONG_SRV}/services/sites/$site"

  # These are the main directories that should be readable the the web. 
  local creates="
    backup
    drupal
    drupal/files
    drupal/files/css
    drupal/files/js
    drupal/files/civicrm
    drupal/files/civicrm/persist"

  # If this is a dev instance or a clone, we don't make a modules, themes,
  # custom-civicrm and libraries directories because we pull that in via git.
  # If it's live we do.
  if [ "$LONG_LIVE" = "y" ] && ! long_is_clone "$site"; then
    creates="$creates
      drupal/modules
      drupal/themes
      drupal/libraries
      drupal/custom-civicrm
      drupal/custom-civicrm/php
      drupal/custom-civicrm/templates"
  else
    # It is a dev instance or clone, so git pull instead of adding these files.
    mkdir -p "${dir}/drupal"
    long_gitify_site "$site"
  fi
  local create=
  for create in $creates; do
    mkdir -p "${dir}/${create}"
    perms=$(stat -c "%A" "${dir}/${create}")
    if [ "$perms" != "drwxr-xr-x" ]; then
      chmod 0755 "${dir}/${create}"
    fi
  done

  # Certain directories should not be accessible by the web user, only 
  # by the user running the PHP application.
  # See https://civicrm.org/advisory/civi-sa-2014-001-risk-information-disclosure
  # The private/extensions/{tmp,cache} are there *only* to handle the 
  # extensions tmp and cache directories. Extensions are in
  # sites/all/extensions and tmp and cache is symlinked here.
  local not_web_accessible="
    drupal/files/civicrm/ConfigAndLog
    drupal/files/civicrm/templates_c
    drupal/files/civicrm/upload
    drupal/files/civicrm/custom
    drupal/private
    drupal/private/extensions
    drupal/private/extensions/tmp
    drupal/private/extensions/cache"
  # Prohibit web access by removing other access. Only the user and the
  # group owners will be able to access the files. And only the owner will
  # be able to write to them.
  for create in $not_web_accessible; do
    # We only need to make this change at the top level - no need for
    # recursive.
    mkdir -p "${dir}/${create}"
    perms=$(stat -c "%A" "${dir}/${create}")
    if [ "$perms" != "drwxr-x---" ]; then
      chmod 0750 "${dir}/${create}" 
    fi
  done
  
  # One exception: private/temp should be writable by the group ($LONG_HOST_USER)
  # so that the host can create temporary files to be deleted after being
  # executed in the container. See the long_exec_in_container function.
  mkdir -p "${dir}/drupal/private/temp"
  perms=$(stat -c "%A" "${dir}/drupal/private/temp")
  if [ "$perms" != "drwxrwxr-x" ]; then
    chmod 0775 "${dir}/drupal/private/temp"
  fi

  # Now that the right modes are set, chown the files to the right users. 
  local web_writable="drupal/files drupal/private"
  for foo in $web_writable; do
    # Maintain group ownership by the $LONG_HOST_USER user so we can read the
    # files from the host for convenience and trouble-shooting.
    sudo chown -R longshore-php:"$LONG_HOST_USER" "${dir}/${foo}"
  done

  # Give the longshore-php user group ownership over the drupal directory
  # so we can easily flip on and off group write/read access when
  # installing drupal and civicrm.
  sudo chgrp longshore-php "${dir}/drupal"
}

# Low lever site container creation. Call long_create_container instead
# if possible.
long_create_site_container() {
  local site="$1"
  local db="$2"
  local platform="$3"
  local dir="${LONG_SRV}/services/sites/$site"

  # Sanity check - make sure platform exists.
  if [ ! -d "${LONG_SRV}/platforms/${platform}" ]; then
    long_die "That platform doesn't seem to exist (%s)." 1 "$platform"
  fi

  # Another sanity check - if the site exists on a different sibling, we
  # should get a confirmation to proceed. This helps us avoid accidentally
  # creating a duplicate site.
  me=$(hostname)
  long_set_site_sibling "$site"
  if [ -n "$LONG_SITE_SIBLING" -a "$LONG_SITE_SIBLING" != "$me" ]; then
    long_prompt "A site with the same name (%s) exists on a different sibling (%s). Continue?" \
      "$site" "$LONG_SITE_SIBLING"
    if [ "$reply" != "y" ]; then
      long_log "Not continuing." info
      exit 0
    fi
  fi

  if [ "$db" != "mysqlhost" ]; then
    # Ensure that the database container exists and is running. It has to
    # be running, not just created, so we can create the database and database
    # username/password.
    #
    # Normally, we would simply call long_container_up - however, that 
    # function in turn calls long_container_create - which will try to 
    # create the mysql container while respecting the LONG_FORCE setting
    # intended for the site. We don't want to force re-ceate the database
    # container everytime we force re-create the site container.
    #
    # To avoid that problem, we first call the container create mysql helper 
    # function directly which will return if the container already exists.
    long_create_mysql_container "$db"
    long_container_up mysql "$db"
  fi

  # Build out directories. 
  long_create_site_directories "$site"

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  long_set_php_port "$site" 

  # Create nginx configuration
  # Check for aliases.
  local aliases=
  [ -f "${dir}/env/ALIASES" ] && aliases=$(cat "${dir}/env/ALIASES")
  long_create_nginx_site_conf "$site" "$platform" "$LONG_PHP_PORT" "$aliases"

  # Ensure that the database exists and that we have a my.cnf file.
  #
  # We are not going to do a proper drupal and civicrm installation 
  # because that will take a long time and we may only want to create
  # the container in order to import an existing database. So, just create
  # the database and user and record the password in my.cnf.
  #
  # The actual installation, if needed, will happen in longshore site-setup
  long_create_db "$site" "$db"

  # Bail if the container already exists. All remaining items in this
  # function are only needed if the site has never been created.
  if long_container_exists "$site"; then
    return
  fi 
  # Ensure the container is accessible on localhost so nginx can reach it.
  local publish="-p 127.0.0.1:$LONG_PHP_PORT:9000"

  # We need to add an /etc/hosts entry for the host so that esmtp-run 
  # can relay email via the host (it's configured in the container in
  # /etc/esmtprc).
  local ip=$(ip addr show dev docker0 | grep "inet " | awk '{print $2}' | cut -d/ -f1)

  # Make sure we can communicate with the db container.
  local link=
  local addhost=

  if [ "$db" != "mysqlhost" ]; then
    link="--link $db:$db"
    addhost="--add-host dockerhost:$ip"
  else
    addhost="--add-host dockerhost:$ip --add-host mysqlhost:$LONG_MYSQL_HOST_IP"
  fi

  # If this is a dev site, we also need to link to the smtp container
  # so we can send/receive email without actually sending any email.
  if [ "$LONG_LIVE" != "y" ]; then
    link="$link --link smtp:smtp"
  fi

  # Docker
  docker $LONG_DOCKER_LOG_ARG create --log-driver "$LONG_DEFAULT_LOG_DRIVER" --name "$site" \
    $addhost \
    -v "${LONG_SRV}/platforms/${platform}:/var/www/powerbase" \
    -v "${dir}/drupal:/var/www/powerbase/sites/default" \
    -v "${LONG_SHARE}/drush:/var/www/.drush" \
    -e "LONG_LIVE=$LONG_LIVE" \
    -e "PB_URL=${site}.${LONG_DEFAULT_DOMAIN}" \
    --restart unless-stopped \
    $LONG_DOCKER_MEMORY_LIMIT \
    $link \
    $publish \
    ptp-powerbase:latest php-fpm7.3 || long_die "Failed to create the container %s" 1 "$site"

  long_clear_sibling_cache
}

long_create_container() {
  local type="$1"
  local name="$2"
  local db_host="$3"
  local platform="$4"

  if [ -z "$name" ]; then
    if [ "$type" = "phpmyadmin" ]; then
      name="$type"
    else
      long_die "Containers of this type (%s) need a name passed as second argument." 1 "$type"
    fi
  fi

  # Delete the container if force is specified.
  if [ "$LONG_FORCE" = "1" ]; then
    # If the container is running, that is an error. This command won't
    # start a container after creating it, so we shouldn't stop a container
    # either.
    if long_container_running "$name"; then
      long_die "The container %s is running. Please stop it first."
    fi
    docker $LONG_DOCKER_LOG_ARG rm "$name"
  fi

  # NOTE: These functions not only create the docker containers, but also
  # do a number of idempotent prepration steps. These steps should be
  # taken even if the container already exists, so we wait on the check to see
  # if the container exists until the last docker create statement in each
  # specific container_create function.
  
  # Create a mysql container.
  if [ "$type" = "mysql" ]; then
    long_create_mysql_container "$name"
  elif [ "$type" = "phpmyadmin" ]; then
    long_create_phpmyadmin_container 
  elif [ "$type" = "site" ]; then
    # Figure out which database and platform to use if it's not specified.
    if long_container_exists "$name"; then
      # If the container already exists, and we are not specifying a db_host,
      # then use the db_host specified in the container.
      long_set_site_db_host "$name"
      if [ -z "$db_host" ]; then
        if [ -z "$LONG_SITE_DB_HOST" ]; then
          # This is a fatal error.
          long_die "The site container (%s) exists but doesn't have a db_host set." 1 "$name"
        fi
        db_host="$LONG_SITE_DB_HOST"
      else
        # If it exists and we are specifying a db_host, make sure they match.
        if [ "$db_host" != "$LONG_SITE_DB_HOST" ]; then
          long_die "Mis-matched database host for %s. Calling function said: %s, existing container says: %s" \
            1 "$name" "$db_host" "$LONG_SITE_DB_HOST"
        fi
      fi

      # Now repeat for platform.
      long_set_site_platform "$name"
      if [ -z "$platform" ]; then
        if [ -z "$LONG_SITE_PLATFORM" ]; then
          # This is a fatal error.
          long_die "The site container (%s) exists but doesn't have a platform set." 1 "$name"
        fi
        platform="$LONG_SITE_PLATFORM"
      else
        # If it exists and we are specifying a platform, make sure they match.
        if [ "$platform" != "$LONG_SITE_PLATFORM" ]; then
          long_die "Mis-matched platform for %s. Calling function said: %s, existing container says: %s" \
            1 "$name" "$platform" "$LONG_SITE_PLATFORM"
        fi
      fi
    else
      # If the container doesn't exist and we aren't specifying a db_host, 
      # check for an existing settings.php file - this may be the case if the
      # container was deleted in order to be re-created. Use the db_host
      # specified by the previoulsy existing site.
      if [ -z "$db_host" ]; then
        local settings="${LONG_SRV}/services/sites/${name}/drupal/settings.php"
        if [ -f "$settings" ]; then
          db_host=$(egrep "'host' => '(mysqlhost|db[0-9a-z-]+)'," "$settings" | cut -d'>' -f2 | tr -d "', ")
        fi 
        
      fi
      # Ditto for platform, however, we'll need to check the nginx file.
      # And, we'll use the default platform if the site doesn't exist.
      if [ -z "$platform" ]; then
        local nginx_path="${LONG_NGINX_SITES_ENABLED}/${name}.conf"
        if [ -f "$nginx_path" ]; then
          platform=$(grep 'root  /var/www/powerbase/ourpowerbase-d' "$nginx_path" | egrep -o 'ourpowerbase-d[0-9]+-c[0-9.]+')
        fi
        # We use the default if the site is brand new.
        if [ -z "$platform" ]; then
          platform="$LONG_DEFAULT_PLATFORM"
        fi
      fi
    fi
    if [ -z "$db_host" ]; then
      long_die "This site has never been created on this host. Please specify the db host."
    fi
    long_log "Details\nsite: %s\ndb_host: %s\nplatform: %s" info "$name" "$db_host" "$platform"
    long_create_site_container "$name" "$db_host" "$platform" 
  else
    long_die "I don't know how to make a container of that type (%s)." 1 "$type"
  fi
}

long_set_site_platform() {
  local site="$1"
  # .HostConfig.Binds shows which volumes are mounted from the host. The
  # first one listed should always be the platform. It will return the 
  # full path to the platform - so we use basename to reduce it to just
  # the platform name.
  local platform_path=$(docker $LONG_DOCKER_LOG_ARG inspect -f '{{.HostConfig.Binds}}' "$site" | egrep -o "/srv/longshore/platforms/ourpowerbase-[a-z0-9.-]*")
  LONG_SITE_PLATFORM=$(basename "$platform_path")
}

long_set_site_db_host() {
  local site="$1"
  LONG_SITE_DB_HOST=$(docker $LONG_DOCKER_LOG_ARG inspect -f '{{.HostConfig.Links}}' "$site"|  egrep -o "/db[0-9a-z-]+:" | tr -d '/:')

  # If not database container is set in the site container, then we assume it's using the shared mysqlhost
  # container.
  if [ -z "$LONG_SITE_DB_HOST" ]; then
    LONG_SITE_DB_HOST=mysqlhost
  fi
}

# Install drupal from scratch.
long_install_drupal() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}"

  long_set_site_platform "$site"

  # Copy default settings file into place.
  local default_settings_source="${LONG_SRV}/platforms/${LONG_SITE_PLATFORM}/sites/default/default.settings.php"
  cp "$default_settings_source" "${dir}/drupal/"

  # Grant the longshore-php group write access to the container to it can
  # create the settings.php file (the longshore-php user should already
  # have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  # Retrieve the password, db user, and db host.
  local dbpassword=$(grep ^password "${dir}/my.cnf" | cut -d= -f2)
  local dbuser=$(grep ^user "${dir}/my.cnf" | cut -d= -f2)
  local dbname=$(grep ^database "${dir}/my.cnf" | cut -d= -f2)
  long_set_site_db_host "$site"

  if [ "$LONG_SITE_DB_HOST" = "<no value>" ]; then
    long_die "This site (%s) has no database configured. You should probably re-create it." 1 "$site"
  fi

  # Creating a php file to be executed in the container. This approach
  # avoids sending passwords via the command line.
  local install_file=$(mktemp "${LONG_SITE_TMP}/install.XXXXXXX.php");
cat << EOF > "$install_file"
  <?php
  drush_set_option('account-pass', '$dbpassword');
  drush_set_option('account-name', 'admin');
  drush_set_option('site-name', '$site');
  drush_set_option('site-mail', 'info@progressivetech.org');
  drush_set_option('account-mail', 'info@progressivetech.org');
  drush_set_option('db-url', 'mysql://${dbuser}:${dbpassword}@${LONG_SITE_DB_HOST}/${dbname}');
  drush_core_pre_site_install();
  drush_core_site_install(NULL);
EOF

  # Ensure that the www-data user can read it.
  chmod 644 "$install_file"

  # Translate file path to work in container.
  c_install_file="/var/www/powerbase/sites/default/private/temp/$(basename $install_file)"

  long_exec_drush_cmd "$site" "-q -y php-script '$c_install_file'"

  # Cleanup
  rm "$install_file"

  # Reset permissions. 
  # Regain ownership of the settings.php file.
  sudo chown "$LONG_HOST_USER" "${dir}/drupal/settings.php"

  # And restrict access.
  chmod 0640 "${dir}/drupal/settings.php"

  # Also re-restrict group access to the enclosing directory.
  chmod 755 "${dir}/drupal"
}

# Assuming we have a functional drupal, install CiviCRM
long_install_civicrm() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}"

  # Grant the longshore-php group write access to the container can
  # create the settings.php file (the longshore-php user should already
  # have group ownership over the directroy from site-create).
  chmod 775 "${dir}/drupal"

  # Create the file to be executed. We can't simply run drush -y civicrm-install
  # because civicrm module is not yet enabled which means civicrm.drush.inc commands
  # are not available to us, so we use a helper command in lsd.
  long_set_site_base_url "$site"
  long_exec_drush_cmd "$site" "-q -y lsd-civicrm-install --base_url='$LONG_SITE_BASE_URL'"

  # Reset permissions. 
  # Regain ownership of the settings.php file.
  sudo chown "$LONG_HOST_USER" "${dir}/drupal/civicrm.settings.php"

  # And restrict access.
  chmod 0640 "${dir}/drupal/civicrm.settings.php"

  # Also re-restrict group access to the enclosing directory.
  chmod 755 "${dir}/drupal"
}

long_import_backup() {
  local site="$1"
  local path="$2"

  if [ -z "$path" ]; then
    path="${LONG_SRV}/services/sites/${site}/backup/${site}.sql.gz"
  fi

  long_execute_site_query "$site" "$path"

  # Ensure Triggers are created.
  long_exec_drush_cmd "$site" "php-eval '_civicrm_init(); CRM_Core_DAO::triggerRebuild()'"
}

# Drop all tables in a database. Useful when importing a backup over an existing
# database to ensure no stale temp tables or other tables are left around. Pass
# civicrm_only as second argument to only drop tables that start with civicrm_.
long_drop_tables() {
  local site="$1"
  local civicrm_only="$2"

  get_tables_temp=$(mktemp)
  drop_tables_temp=$(mktemp)

  # The drupal blocked_ips table is needed for the drush command sql-query to function.
  local exclude="(TABLE_NAME|blocked_ips)"

  # By defalt include all tables in DROP statement.
  local include="."
  if [ -n "$civicrm_only" ]; then
    include="^civicrm_"
  fi

  echo "SELECT TABLE_NAME, TABLE_TYPE FROM information_schema.TABLES WHERE TABLE_SCHEMA = '$site' AND TABLE_TYPE NOT LIKE 'SYSTEM VIEW'" > "$get_tables_temp"
  long_execute_site_query "$site" "$get_tables_temp" | egrep -v "^$exclude" | egrep "$include" | while read table table_type; do
    entity=TABLE
    if [ "$table_type" == "VIEW" ]; then
      entity=VIEW
    fi
    printf "SET FOREIGN_KEY_CHECKS=0; DROP %s %s;\n" "$entity" "$table" >> "$drop_tables_temp"
  done
  # Only run if we have a drop file that is more than 0 bytes (i.e. 
  # don't run if there are no tables in the database)
  if [ -s "$drop_tables_temp" ]; then
    cat "$drop_tables_temp"
    table_count=$(wc -l "$drop_tables_temp" | cut -d\  -f1)
    long_prompt "Deleting %s tables from the database for site '%s'" "$table_count" "$site"
    if [ "$reply" = "y" ]; then
      long_log "Deleting the tables" info
      long_execute_site_query "$site" "$drop_tables_temp"
    else
      long_log "Not deleting the tables" info
      long_prompt "Continuing to the next step which might be an import." 
      if [ "$reply" = "n" ]; then
         rm "$get_tables_temp"
         rm "$drop_tables_temp"
        long_die "Dying. Bye."
      fi
    fi
  fi
  rm "$get_tables_temp"
  rm "$drop_tables_temp"
}

# Once the site is created, this function ensures that both Drupal and
# CiviCRM are minimally functional and email delivery is ready to go.
long_setup_site() {
  local site="$1"

  if ! long_container_running "$site"; then
    long_die "The container is not running. Please start it first." 
  fi
  
  # Populate the $LONG_SITE_TMP_VAR variable which is used to execute
  # commands in the container.
  long_init_site_tmp_var "$site"

  # Ensure database and settings files are properly installed.
  long_install_site "$site"

  # Ensure all basic drupal and civicrm paths and urls are set. 
  long_exec_drush_cmd "$site" "lsd-set-paths"

  # Ensure the esmtprc is properly configured to forward email to the right
  # host (bulk.ourpowerbase.net:25 on live sites which is configured by
  # default) and the smtp:25 on dev sites, which expects the dev host
  # to be running the mail container.
  
  if [ "$LONG_LIVE" = "n" ]; then
    docker $LONG_DOCKER_LOG_ARG exec "$site" /bin/sed -i 's/^hostname=bulk.ourpowerbase.net:25$/hostname=smtp:25/' \
      /etc/esmtprc
  fi

}
# There are some site configurations that should be set once to the default
# and then not changed, in case the site was to make their own customizations.
long_configure_site_once() {
  local site="$1"
  local force="$2"

  # Populate the $LONG_SITE_TMP_VAR variable which is used to execute
  # commands in the container.
  long_init_site_tmp_var "$site"

  # Set PTP configurations. 
  if [ "$force" = "force" ]; then
    long_log "Running drush ptp-configure-once --force" info
    long_exec_drush_cmd "$site" "pbd-configure-once --force" "LONG_LIVE"
  else
    long_log "Running drush ptp-configure-once" info
    long_exec_drush_cmd "$site" "pbd-configure-once" "LONG_LIVE"
  fi
}

# Once the site is setup, ensure that it is configured in the PTP/PowerBase
# way.
long_configure_site() {
  local site="$1"

  # Populate the $LONG_SITE_TMP_VAR variable which is used to execute
  # commands in the container.
  long_init_site_tmp_var "$site"

  # Set PTP configurations. 
  long_log "Running drush ptp-configure" info
  long_exec_drush_cmd "$site" "ptp-configure" "LONG_LIVE"

  # Ensure CIVICRM_MAIL_SMARTY is configured so we can use smarty in our
  # mail templates.
  local drupal="${LONG_SRV}/services/sites/${site}/drupal"
  local civicrm_settings="${drupal}/civicrm.settings.php"
  if ! grep "CIVICRM_MAIL_SMARTY', 1" "$civicrm_settings" > /dev/null; then
    sed -i "s/'CIVICRM_MAIL_SMARTY', 0/'CIVICRM_MAIL_SMARTY', 1/" "$civicrm_settings"
    # Ensure we preserve the proper permissions.
    sudo chgrp longshore-php "$civicrm_settings"
    chmod 0640 "$civicrm_settings"
  fi

  # Now ensure we are including our local.settings.php file in settings.php
  local drupal_settings="${drupal}/settings.php"
  if ! grep local.settings.php "$drupal_settings" > /dev/null; then
    cat "${LONG_SHARE}/templates/include.local.settings.php" >> "$drupal_settings"
  fi

  # Populate the local.settings.php
  local local_settings="${drupal}/local.settings.php"
  cat "${LONG_SHARE}/templates/local.settings.php" | sed \
    -e "s/LONG_ERROR_REPORTING/$LONG_ERROR_REPORTING/" \
    > "${drupal}/local.settings.php"

  long_configure_imap "$site"
  long_log "Running drush pbd-configure" info

  local envvars="LONG_GOOGLE_RECAPTCHA_SECRET_KEY LONG_GOOGLE_RECAPTCHA_SITE_KEY LONG_GOOGLE_MAP_GEO_API_KEY LONG_LIVE"
  long_exec_drush_cmd "$site" "-y pbd-configure" "$envvars"
}

# Ensure there are the required IMAP users installed on the IMAP server
# and the site is configured properly to connect to the server.
long_configure_imap() {
  local site="$1"

  # Don't run on dev sites.
  if [ "$LONG_LIVE" != "y" ]; then
    long_log "Not checking IMAP user on dev site." info
    return
  fi
  # We have to create a user with -activities appended to it, and the total
  # length can't exceed 32 characters, so limit usernames to the first
  # 21 characters (-activities is 11, 21 + 11 = 32).
  # FIXME: What if we have two users and the first 21 characters are the
  # same? Like with a clone site?
  local imap_base_user=$(echo ${site:0:21})
  local user=

  # By default, we only set the password when we create a new user.
  local set_password=n

  for user in ${imap_base_user}-activities ${imap_base_user}-returns; do
    long_log "Checking IMAP user '%s'" info "$user"
    # Check if user already exists on the host.
    if ! $LONG_MANAGE_IMAP_USER_CMD exists "$user"; then
      long_log "IMAP user '%s' doesn't exist, adding." info "$user"
      # Create the user
      $LONG_MANAGE_IMAP_USER_CMD add "$user"
      set_password=y
    fi

    # Sometimes the PowerBase password is out of sync, in this special
    # case we can use the env variable LONG_SET_IMAP_PASSWORD to signal
    # that it should be reset.
    if [ -n "$LONG_SET_IMAP_PASSWORD" ]; then
      long_log "Overriding IMAP password, updating the password." info
      set_password=y
    fi

    if [ "$set_password" = "y" ]; then
      # Set the password.
      pass=$($LONG_MANAGE_IMAP_USER_CMD passwd "$user" 2>/dev/null)
      if [ -z "$pass" ]; then
        long_die "Failed to get password for IMAP user '%s'" 1 "$user"
      fi
      # Configure user and password in CiviCRM, ensuring we don't pass
      # the password exposed via the command line.
      long_configure_civicrm_imap_user "$site" "$user" "$pass"
    fi
  done
}

# Configure the given IMAP user and password in CiviCRM without passing
# password via the command line.
long_configure_civicrm_imap_user() {
  local site="$1"
  local user="$2"
  local pass="$3"

  long_init_site_tmp_var "$site"

  # Creating a php file to be executed in the container. This approach
  # avoids sending passwords via the command line.
  local imap_file=$(mktemp "${LONG_SITE_TMP}/imap.XXXXXXX.php");
cat << EOF > "$imap_file"
  <?php
  ptp_configure_imap_user('$user', '$pass', '$LONG_IMAP_HOST');
EOF

  # Ensure that the www-data user can read it.
  chmod 644 "$imap_file"

  # Translate file path to work in container.
  c_imap_file="/var/www/powerbase/sites/default/private/temp/$(basename $imap_file)"
  long_exec_drush_cmd "$site" "-q -y php-script '$c_imap_file'"

  # Cleanup
  rm "$imap_file"

}

# Ensure we have a Drupal and CiviCRM database installed and the settings.php
# files properly setup.
long_install_site() {
  local site="$1"

  # Check for settings.php. If it exists, we assume drupal is properly
  # installed. NOTE: if you delete an existing settings.php file you will cause
  # the database to be re-created. If it doesn't exist, we either import from
  # backup or do a fresh instal.
  local dir="${LONG_SRV}/services/sites/${site}"
  local drupal="${dir}/drupal"
  local drupal_settings="${drupal}/settings.php"
  local civicrm_settings="${drupal}/civicrm.settings.php"

  if [ ! -f "$drupal_settings" ]; then
    long_log "No drupal settings.php file is present." info
    # Make sure we have a password - that should be set by the site-create command.
    if [ ! -s "${dir}/my.cnf" ]; then
      long_die "No settings.php file and no my.cnf - I can't setup the site."
    fi

    # Check for a database backup.
    if [ ! -s "${dir}/backup/${site}.sql.gz" ]; then
      # There is no database to restore. We need to do a standard Drupal
      # installation.
      long_log "No backup database. Installing Drupal." info
      long_prompt "Installing Drupal/CiviCRM from scratch. Any existing DB will be destroyed"
      if [ "$reply" != "y" ]; then
        long_log "Not continuing, as directed."
        return
      fi
      long_install_drupal "$site"
      long_log "Installing CiviCRM." info
      long_install_civicrm "$site"
    else
      # We have a backup file. That means we only need to create a drupal
      # settings.php file and import the database. 
      long_log "Importing database from backup." info
      long_prompt "Importing database, any existing DB will be destroyed"
      if [ "$reply" != "y" ]; then
        long_log "Not continuing, as directed."
        return
      fi
      long_set_site_db_host "$site"
      if [ "$LONG_SITE_DB_HOST" = "<no value>" ]; then
        long_die "This site (%s) has no database configured. You should probably re-create it." 1 "$site"
      fi
      long_create_drupal_settings "$site" "$LONG_SITE_DB_HOST"
      long_import_backup "$site"
    fi
  fi
  if [ ! -f "$civicrm_settings" ]; then
    # At this point, we expect to have a working Drupal installation.
    # The only reason there might not be a civicrm file is if we imported
    # our database.
    long_create_civicrm_settings "$site"
  fi
}

# Delete a site container and all related containers and data
long_destroy_site() {
  local site="$1"
  
  # Remove the nginx file first so the site is no longer accessible.
  long_log "Disabling nginx configuration." info
  rm -f "${LONG_NGINX_SITES_ENABLED}/${site}.conf"
  rm -f "${LONG_NGINX_SITES_ENABLED}/${site}-redirect.conf"
  long_nginx_reload

  if long_container_running "$site"; then
    long_log "Stopping container." info
    docker $LONG_DOCKER_LOG_ARG stop "$site"
  fi

  # Kill the database.
  long_set_site_db_host "$site"
  # If no database is configured, this is not an error, just continue.
  if [ -n "$LONG_SITE_DB_HOST" -a "$LONG_SITE_DB_HOST" != "<no value>" ]; then

    # Ensure the db container is running so we can drop the database.
    if [ $"LONG_SITE_DB_HOST" != "mysqlhost" ]; then
      long_container_up mysql "$LONG_SITE_DB_HOST"
      while ! long_up_long_enough "$LONG_SITE_DB_HOST" 60; do
        long_log "Waiting 10 more seconds to ensure database has started." info
        sleep 10 
      done
    fi
    temp=$(mktemp)
    echo "DROP DATABASE IF EXISTS \`$site\`" > "$temp"
    long_log "Dropping database (%s) on host (%s)." info "$site" "$LONG_SITE_DB_HOST"
    long_execute_root_query "$LONG_SITE_DB_HOST" "$temp"  
    rm "$temp"
    # If we are using new style db hosts - one per site - we should drop the db
    # host. If we are using old style hosts (db01, db02, which are sometimes shared)
    # we should not drop the host.
    # Only prompt to drop the db host if we are NOT using the db01 style name.
    if ! echo "$LONG_SITE_DB_HOST" | egrep 'db[0-9]+$'; then
      long_prompt "Deleting DB host" "$LONG_SITE_DB_HOST"
      if [ "$reply" = "y" ]; then
        long_log "Stopping and Dropping db container (%s)." info "$LONG_SITE_DB_HOST"
        docker $LONG_DOCKER_LOG_ARG stop "$LONG_SITE_DB_HOST"
        docker $LONG_DOCKER_LOG_ARG rm "$LONG_SITE_DB_HOST"

        # Now delete the database directory
        local db_path="${LONG_SRV}/services/databases/${LONG_SITE_DB_HOST}"
        if [ -d "$db_path" ]; then
          rm -rf "$db_path"
        fi
      fi
    fi
  fi

  long_log "Deleting container" info
  if long_container_exists "$site"; then
    docker $LONG_DOCKER_LOG_ARG rm "$site"
  fi

  # Delete the data directory.
  long_log "Removing data directory" info

  # It might be a disabled site or an active site. Pick the right directory.
  local data_dir=
  local site_was_disabled=n
  if [ -d "${LONG_SRV}/services/sites/${site}" ]; then
    data_dir="${LONG_SRV}/services/sites/${site}"
  fi
  if [ -d "${LONG_SRV}/services/sites.disabled/${site}" ]; then
    data_dir="${LONG_SRV}/services/sites.disabled/${site}" 
    site_was_disabled=y
  fi

  if [ -d "$data_dir" ]; then
    # Some files and directories may be owned by longshore-php, so reclaim
    # onwership first.
    sudo chown -R "$LONG_HOST_USER" "${data_dir}/drupal/files"
    sudo chown -R "$LONG_HOST_USER" "${data_dir}/drupal/private"
    rm -rf "${data_dir}"
  fi

  long_clear_sibling_cache

  if [ "$site_was_disabled" = "y" ]; then
    # Regenerate the nginx list of disabled sites so this was is removed.
    long_log "Regenerating disabled site list for nginx" info
    long_generate_nginx_disabled_sites_config
    long_nginx_reload
  fi

  # Kill the IMAP user on the remote or local host, provided this site 
  # is not located on a different server now.
  if ! long_check_site_exists "$site"; then
    long_log "This site is not on other siblings so killing IMAP users." info
    $LONG_MANAGE_IMAP_USER_CMD delete "${site}-activities" 2>/dev/null
    $LONG_MANAGE_IMAP_USER_CMD delete "${site}-returns" 2>/dev/null
  fi

  long_log "Please manually delete the DNS record." info
}

# Disable a site container. 
long_disable_site() {
  local site="$1"

  if long_container_running "$site"; then
    # Stop the container.
    docker $LONG_DOCKER_LOG_ARG stop "$site"
  fi

  # Ensure disabled sites directory exists.
  mkdir -p "${LONG_SRV}/services/sites.disabled"

  # Move to disabled directory if necessary and clear sibling cache 
  if [ ! -d "${LONG_SRV}/services/sites.disabled/${site}" ]; then
    if [ ! -d "${LONG_SRV}/services/sites/${site}" ]; then
      long_die "The site doesn't seem to have a site directory. Can't disable."
    fi
    mv "${LONG_SRV}/services/sites/${site}" "${LONG_SRV}/services/sites.disabled"
  fi
  long_clear_sibling_cache
  
  # Delete nginx configuration
  rm -f "${LONG_NGINX_SITES_ENABLED}/${site}.conf"

  # Regenerate nginx disabled sites configuration file and reload nginx.
  long_generate_nginx_disabled_sites_config
  long_nginx_reload
}

# Enable a site container. 
long_enable_site() {
  local site="$1"

  # Move to enabled directory if necessary and clear sibling cache 
  if [ ! -d "${LONG_SRV}/services/sites/${site}" ]; then
    if [ ! -d "${LONG_SRV}/services/sites.disabled/${site}" ]; then
      long_die "The site doesn't seem to have a site directory. Can't enable."
    fi
    mv "${LONG_SRV}/services/sites.disabled/${site}" "${LONG_SRV}/services/sites/"
  fi
  long_clear_sibling_cache
  
  # Regenerate diabled sites to remove this one.
  long_generate_nginx_disabled_sites_config

  long_container_up site "$site"
  long_nginx_reload
}
# Generate list of disabled sites.
long_set_disabled_sites() {
  LONG_DISABLED_SITES=$(ls "${LONG_SRV}/services/sites.disabled" 2>/dev/null)
}

long_set_default_db() {
  site="$1"
  if [ -f "$LONG_ETC"/my.cnf ]; then
    LONG_DEFAULT_DB="mysqlhost"
  else
    LONG_DEFAULT_DB="db${site}"
  fi
}

# Create a special nginx configuration file for diabled sites.
long_generate_nginx_disabled_sites_config() {
  long_set_disabled_sites

  local target="${LONG_NGINX_SITES_ENABLED}/disabled.conf"
  # If there are no disabled sites, then ensure the configuration is removed
  if [ -z "$LONG_DISABLED_SITES" ]; then
    rm -rf "$target"
    return
  fi

  # Generate server list
  local server_names=
  local disabled_site=
  local template="${LONG_SHARE}/templates/nginx-disabled.conf"
  for disabled_site in $LONG_DISABLED_SITES; do
    if [ -z "$server_names" ]; then
      server_names="${disabled_site}.${LONG_DEFAULT_DOMAIN}"
    else
      server_names="${server_names} ${disabled_site}.${LONG_DEFAULT_DOMAIN}"
    fi
  done

  local access_log="disabled.access.log"
  local web_root="${LONG_SHARE}/www/disabled"

  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    local tls_or_not="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    local server_name=
    for disabled_site in $LONG_DISABLED_SITES; do
      [ -z "$disabled_site" ] && continue
      long_create_nginx_redirect "$disabled_site" "${disabled_site}.${LONG_DEFAULT_DOMAIN}"
    done
  else
    local tls_or_not="listen ${LONG_IP_ADDR}:80;"
  fi
  cat "$template" | \
    sed \
    -e "s#LONG_TLS_OR_NOT#$tls_or_not#" \
    -e "s#LONG_WEB_ROOT#$web_root#" \
    -e "s#LONG_SITE_URL#$server_names#" \
    -e "s#LONG_ACCESS_LOG#$access_log#" \
    > "$target"
}

# Access the given site's database via mysql cli
long_launch_site_sql_cli() {
  local site="$1"
  local mycnf="${LONG_SRV}/services/sites/${site}/my.cnf"
  if [ ! -f "$mycnf" ]; then
    long_die "Can't find site my.cnf file (%s)" 1 "$mycnf"
  fi
  mysql --defaults-file="$mycnf"
}

# Access the given database as root via mysql cli
long_launch_root_sql_cli() {
  local db="$1"
  if [ "$db" == "mysqlhost" ]; then
    local mycnf="${LONG_ETC}/my.cnf"
  else
    local mycnf="${LONG_SRV}/services/databases/${db}/my.cnf"
  fi
  if [ ! -f "$mycnf" ]; then
    long_die "Can't find db my.cnf file (%s)" 1 "$mycnf"
  fi
  mysql --defaults-file="$mycnf"
}

# Clone a site from the same server
long_clone_site() {
  local site="$1"
  local source_base="/srv/longshore/services/sites/${site}"
  local source_git="${source_base}/git"
  local source_drupal="${source_base}/drupal"

  local clone_site="${site}clone"
  long_log "Cloning site %s to %s" "$site" "$clone_site"

  local target_base="${source_base}clone"
  local target_drupal="${target_base}/drupal"

  # Make sure source git repo is clean and warn if it isn't.
  long_log "Checking if %s site has clean git repo" info "$site"
  long_check_git_clean "$site"

  # Build out the directory structure. This will gitify the local repo
  # if necessary, which will pull in the code from live version of the
  # site.
  long_log "Creating site directories for %s" info "$clone_site"
  long_create_site_directories "$clone_site"

  # Now get files.

  # First we have to chown so we can rsync. After building out the directories,
  # these directories will be owned by longshore-php, not $LONG_HOST_USER.
  sudo chown -R "$LONG_HOST_USER" "${target_drupal}/files"
  sudo chown -R "$LONG_HOST_USER" "${target_drupal}/private"

  # Clear the js, css and template caches
  rm -rf "${target_drupal}"/files/js/*
  rm -rf "${target_drupal}"/files/css/*
  rm -rf "${target_drupal}"/files/civicrm/templates_c/*

  long_log "Sync'ing files" info
  rsync -a --no-owner --no-perms --delete --exclude 'js/*' \
    --exclude 'css/*' --exclude 'civicrm/templates_c/*' \
    --exclude 'civicrm/ConfigAndLog/*' \
    "${source_drupal}/files/" "${target_drupal}/files/"

  long_log "Sync'ing private" info
  rsync -a --no-owner --no-perms --delete \
    "${source_drupal}/private/" "${target_drupal}/private/"

  if [ -f "${source_base}/backup/${site}.sql.gz" ]; then
    long_log "Sync'ing database dump" info
    rsync "${source_base}/backup/${site}.sql.gz" "${target_base}/backup/${clone_site}.sql.gz"
  else
    long_log "No database backup." error
  fi
}

# Fetch a site from the remote server. Copy all files.
long_fetch_site() {
  local site="$1"
  long_log "Getting remote path and server" info 
  local user=longshore
  local default_host=$LONG_DEFAULT_HOST
  local path="/srv/longshore/services/sites/${site}"

  long_log "Get host for site (%s)" info "$site"
  local host=$(ssh ${user}@${default_host}.mayfirst.org "/srv/longshore/bin/longshore site-info '$site'" | grep ^Sibling: | cut -d: -f2 | tr -d ' ')

  if [ -z "$host" ]; then
    long_die "Can't find host" 
  fi

  local source_base="${user}@${host}.mayfirst.org:${path}"
  local source_git="${source_base}/git"
  local source_drupal="${source_base}/drupal"
  local target_base=${LONG_SRV}/services/sites/${site}

  long_prompt "\nSource: %s\ntarget: %s\n" "$source_base" "$target_base"

  # Append drupal for convenience.
  target_drupal="${target_base}/drupal"

  if [ "$reply" != "y" ]; then
    long_die "Not continuing."
  fi

  # Make sure source git repo is clean and warn if it isn't.
  long_check_remote_git_clean "$site" "$host"

  # Build out the directory structure. This will gitify the local repo
  # if necessary.
  long_create_site_directories "$site"

  # Now get files.
  # First we have to chown so we can rsync. After building out the directories,
  # these directories will be owned by longshore-php, not $LONG_HOST_USER.
  sudo chown -R "$LONG_HOST_USER" "${target_drupal}/files"
  sudo chown -R "$LONG_HOST_USER" "${target_drupal}/private"

  # Clear the js, css and template caches
  rm -rf "${target_drupal}"/files/js/*
  rm -rf "${target_drupal}"/files/css/*
  rm -rf "${target_drupal}"/files/civicrm/templates_c/*

  long_log "Sync'ing files" info
  rsync -a --no-owner --no-perms --delete --exclude 'js/*' \
    --exclude 'css/*' --exclude 'civicrm/templates_c/*' \
    --exclude 'civicrm/ConfigAndLog/*' \
    "${source_drupal}/files/" "${target_drupal}/files/"

  long_log "Sync'ing private" info
  rsync -a --no-owner --no-perms --delete \
    "${source_drupal}/private/" "${target_drupal}/private/"

  long_log "Sync'ing database dump" info
  rsync "${source_base}/backup/${site}.sql.gz" "${target_base}/backup/"
}

long_set_sites() {
  local sibling="$1"
  local me=$(hostname)

  # Don't use cache, just show my sites.
  if [ "$sibling" = "$me" ]; then
    LONG_SITES=$(ls "${LONG_SRV}/services/sites")
    return
  fi

  # Generate cache for the other operations
  long_generate_sibling_cache

  # Show sites from another server.
  if [ -n "$sibling" ]; then
    LONG_SITES=$(grep ":${sibling}" "$LONG_SIBLING_CACHE" | cut -d: -f1)
    return
  fi

  # Show all sites.
  LONG_SITES=$(cat "$LONG_SIBLING_CACHE" | cut -d: -f1)
}

# Either create or update a DNS record.
long_create_dns() {
  local site="$1"
  local api_login=pb-api-user
  local url="https://members.mayfirst.org/cp/api.php"
  local fqdn="${site}.${LONG_DEFAULT_DOMAIN}"
  local hosting_order_id=1000002
  local service_id=9
  local dns_ttl=600
  local red_api_password_path=~/.red-api-password
  local api_password=$([ -s "$red_api_password_path" ] && cat "$red_api_password_path")

  # Sanity checking.
  if [ "$LONG_LIVE" != "y" ]; then
    # Don't die, this isn't a fatal error.
    long_log "Not setting DNS in dev instance." info
    return
  fi
  exists=$(dig +short "$fqdn")
  if [ "$?" != 0 ]; then
    long_die "Error checking dns (%s). Output: %s" 1 "$fqdn" "$exists"
  fi
  
  [ -z "$api_password" ] && long_die "Please put your red api password in %s." 1 "$red_api_password_path"
  [ -z "$LONG_IP_ADDR" ] && long_die "The host IP address is not set in longshore.conf"

  if [ -n "$exists" ]; then
    if [ "$exists" = "$LONG_IP_ADDR" ]; then
      long_log "The DNS has already been created and has the same value (%s)." info "$exists"
      return
    else
      long_log "Updating IP address from %s to %s." info "$exists" "$LONG_IP_ADDR"

      # First, get the item id.
      local item_id=$(wget -q "--post-data=action=select&object=item&where:dns_fqdn=${site}.ourpowerbase.net&user_name=${api_login}&where:service_id=${service_id}&where:hosting_order_id=${hosting_order_id}&user_pass=${api_password}&output_format=text" -O- "$url" |  egrep -o '"item_id":[0-9]+' | cut -d: -f2)

      local item_id_count=$(echo "$item_id" | wc -l)
      if [ -z "$item_id" ]; then 
        long_die "Failed to get existing item_id. Try removing -q from wget command." 
        return
      elif [ "$item_id_count" -gt "1" ]; then
        long_log "When searching for domain (%s), found the following item ids: %s" info "${site}.ourpowerbase.net" "$item_id"
        long_die "Found %s item ids, wanted to find just one. Can't update." 1 "$item_id_count"
      else
        post="action=update&output=text&object=item&where:item_id=${item_id}&where:service_id=${service_id}&where:hosting_order_id=${hosting_order_id}&set:dns_ip=${LONG_IP_ADDR}&user_name=$api_login&user_pass=$api_password&output_format=text"
      fi
    fi
  else
    post="action=insert&output=text&object=item&set:service_id=${service_id}&set:hosting_order_id=${hosting_order_id}&set:dns_fqdn=${fqdn}&set:dns_type=a&set:dns_ttl=${dns_ttl}&set:dns_ip=${LONG_IP_ADDR}&set:dns_sshfp_type=0&set:dns_sshfp_algorithm=0&user_name=$api_login&user_pass=$api_password&output_format=text"
  fi

  out=$(wget -q --post-data="$post" -O- "$url")
  if [ "$?" -ne "0" ]; then
    long_die "Failed to use wget when setting the DNS entry."
  fi

  echo "$out" | grep '"is_error":0' > /dev/null

  if [ "$?" -ne "0" ]; then
    echo "$out"
    printf "Command: wget -q -O- --post-data=%s %s\n" "$post" "$url"
    long_die "Failed to create DNS record."
  fi
}

# Dump the database for the given site. By default, use the sites backup
# directory, or specify an alternate location. The backup will be
# compressed.
long_dump_database() {
  local site="$1"
  local dest="$2"
  local temp=$(mktemp)
  local out

  if [ -z "$dest" ]; then
    dest="${LONG_SRV}/services/sites/${site}/backup/${site}.sql.gz"
  fi
  mycnf="${LONG_SRV}/services/sites/${site}/my.cnf"

  # The database name might not be the site name (rap-dpt => rap_dpt)
  local dbname=$(grep ^database "${mycnf}" | cut -d= -f2)

  # All databases are named after the site name. Set pipefail so if 
  # mysqldump fails but gzip succeeds we get an error message.
  out=$(set -o pipefail && mysqldump --defaults-file="$mycnf" "$dbname" | gzip --to-stdout > "$temp")
  
  # Only move into place if it was successful.
  if [ "$?" = 0 ]; then
    mv "$temp" "$dest"
  else
    rm "$temp"
    long_log "Failed to dump database for site %s. Error:" error "$site"
  fi
}

# Check if a container needs an upgrade.
long_needs_upgrade() {
  local container="$1"

  # Figure out when the container was created
  local container_created=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Created}} "$container")

  # Figure out when the image was created.
  local image=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Config.Image}} "$container")
  local image_created=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Created}} "$image")

  # Depending on the version of Docker, we have to strip off time zone
  # handling so date's strtotime function can work properly
  container_created=$(echo "$container_created" | sed 's/ +0000 UTC//')
  image_created=$(echo "$image_created" | sed 's/ +0000 UTC//')

  # Now convert to timestamp so we can properly compare
  container_created=$(date --utc --date "$container_created" '+%s')
  image_created=$(date --utc --date "$image_created" '+%s')

  # Check if the image is newer than the container, that means we have
  # an upgrade to run.
  if [ "$container_created" -le "$image_created" ]; then
    return 0
  else
    return 1
  fi
}

# Print out the packages that need to be upgraded.
long_print_upgradable_packages() {
  local container="$1"
  packages=$(docker $LONG_DOCKER_LOG_ARG exec "$container" bash -c 'apt-get -qq update && apt-get -qq -s dist-upgrade' | awk '/^Inst/ { print $2 }' | tr '\n' ' ')
  printf "$packages"
}

# If a container needs to be upgraded, recreate it.
long_upgrade_container() {
  local container="$1"
  if ! long_needs_upgrade "$container"; then
    long_log "The container %s doesn't need an upgrade." info "$container"
    return
  fi
  long_recreate_container "$container"
}

# Stop, delete and re-create the given container. This is the proper way
# to "upgrade" a container.
long_recreate_container() {
  local container="$1"

  # Get the image so we know what kind of container we are dealing with.
  local image=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Config.Image}} "$container" | cut -d: -f1)

  if [ "$image" != "ptp-php" -a "$image" != "ptp-mysql" -a "$image" != "ptp-powerbase" ]; then
    long_log "I don't know how to handle a container made from the image %s" error "$image"
    return
  fi

  if long_container_running "$container"; then
    long_log "Stopping container %s" info "$container"
    docker $LONG_DOCKER_LOG_ARG stop "$container"
  fi

  # Before we remove the container, we need to get the database host and
  # platform so we can properly re-create.
  if [ "$image" = "ptp-powerbase" ]; then
    long_set_site_db_host "$container"
    long_set_site_platform "$container"
    if [ -z "$LONG_SITE_DB_HOST" -o -z "$LONG_SITE_PLATFORM" -o "$LONG_SITE_DB_HOST" = "<no value>" ]; then
      # If the container's db has just been re-created then it will no 
      # longer show the old container's name. So, one more attempt by
      # looking at the settings.php file
      local settings="${LONG_SRV}/services/sites/${container}/drupal/settings.php"
      if [ -f "$settings" ]; then
        LONG_SITE_DB_HOST=$(egrep "'host' => '(mysqlhost|db[0-9a-z-]+)'," "$settings" | cut -d'>' -f2 | tr -d "', ")
      fi
      if [ -z "$LONG_SITE_DB_HOST" -o -z "$LONG_SITE_PLATFORM" -o "$LONG_SITE_DB_HOST" = "<no value>" ]; then
        # Die before we actually delete this container.
        long_die "Failed to get database host or platform for %s container." 1 "$container"
      fi
    fi
  fi

  long_log "Removing container %s" info "$container"
  docker $LONG_DOCKER_LOG_ARG rm "$container"

  long_log "Recreating container (image: %s) %s" info "$image" "$container"
  if [ "$image" = "ptp-powerbase" ]; then
    local type=site
  elif [ "$image" = "ptp-mysql" ]; then
    local type=mysql
  elif [ "$image" = "ptp-php" ]; then
    local type=phpmyadmin
  fi
  long_container_up "$type" "$container" "$LONG_SITE_DB_HOST" "$LONG_SITE_PLATFORM"
}

# Check if a given site variable ends in clone.
long_is_clone() {
  local site="$1"
  if [ "${site: -5:5}" = "clone" ]; then
    return 0
  fi
  return 1
}

# Check if site has git repo setup properly. Return 0 if it's setup properly
# and 1 if it's not, and 2 if the site doesn't exist.
long_check_git_setup() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}"
  local drupal_dir="${dir}/drupal"

  if [ ! -d "$dir" ]; then
    long_log "Can't find the site directory (%s)." error "$dir"
    return 2
  fi
  local site_git="${drupal_dir}/.git"
  if [ ! -d "$site_git" ]; then
    return 1
  fi

  # If this is a live instance and it's not a clone, make sure the bare
  # repo exists. If it's a dev instance, we don't need a bare repo.
  if [ "$LONG_LIVE" = "y" ] && ! long_is_clone "$site"; then
    local bare_git="${dir}/git" 
    if [ ! -d "$bare_git" ]; then
      long_log "Bare repo doesn't exist." info 
      return 1
    fi
  fi
  return 0
}

# See if a local git repo is clean. Return 0 if it is clean, 1 if there are un-committed
# changes. If un-committed changes log an error.
long_check_git_clean() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/${site}/drupal"

  # Track where we are so we can return after cd'ing
  local cwd=$(pwd)
  cd "$dir"
  local out=$(git status -s)
  cd "$cwd"

  if [ -z "$out" ]; then
    return 0
  fi
  long_log "Warning: Un-committed changes for site %s.\n%s\n" error "$site" "$out"
  return 1
}

# See if a remote git repo is clean. Output error message if it is not
# clean, showing which files are not committed and return 1. Or return
# 0 if clean.
long_check_remote_git_clean() {
  local site="$1"
  local host="$2"
  long_log "Check if remote site (%s) git repo is clean." info "$site"
  (ssh "${user}@${host}.mayfirst.org" "/srv/longshore/bin/longshore site-gitify '$site'")

  if [ "$?" -ne "0" ]; then
    long_log "Doesn't seem like the remote source git repo is clean for %s." error "$site"
    return 1
  else
    long_log "The remote source git repo is clean.\n" info
    return 0
  fi
}

# Setup and check the status of a git repo for the given site.
#
# Every site's drupal directory has customizations saved in a git repo
# that is linked to a bare repo one directory above the drupal directory.
# Only live sites have a bare repo created, dev sites only have the
# regular git repo in the drupal directory, with a remote set to the
# bare repo on the live server (this way, a dev site can pull and push
# to the bare repo on the live server). Similarly, clone sites have a 
# regular repo with a remote set to the bare repo of the live version
# of the site.
#
# This function will create the necessary git repo(s) on either a live or dev
# or clone site, check-in any existing code (if necessary) and then return with
# a code to indicate whether the status of the repo is clean or not.
#
# This function returns 0 if the git repo is clean or 1 if there are
# files/changes to commit, or 2 if the site doesn't exist.
long_gitify_site() {
  local site="$1"
  local dir="${LONG_SRV}/services/sites/$site"
  local drupal_dir="${dir}/drupal"
  local git_dir="${dir}/git"

  if [ ! -d "$dir" ]; then
    long_log "Can't find the site directory (%s)." error "$dir"
    return 2
  fi

  # Ensure our git identity is set.
  local email_out=$(git config --global user.email)
  local name_out=$(git config --global user.name)

  if [ -z "$email_out" ]; then
    long_die "Please set user.email for git: git config --global user.email 'you@example.net'"
  fi
  if [ -z "$name_out" ]; then
    long_die "Please set name.email for git: git config --global user.name 'Your name'"
  fi

  long_check_git_setup "$site"

  if [ "$?" = "0" ]; then
    # The repository is already setup properly. Now determine whether or
    # not it is clean and return the appropriate code.
    long_check_git_clean "$site"
    return "$?"
  fi

  # First make the bare repo, if we are live instance.
  if [ "$LONG_LIVE" = "y" ] && ! long_is_clone "$site"; then
    long_log "Creating bare git repo for new live site." info
    mkdir "$git_dir"

    # Keep track of where we are before we cd
    local cwd=$(pwd)
    cd "$git_dir"
    git init --quiet --bare
    cd "$cwd"

    local post_update="${git_dir}/hooks/post-update"
    printf "#!/bin/bash\ncd %s\nunset GIT_DIR\ngit pull --quiet bare master\n" \
      "$drupal_dir" > "$post_update"
    chmod 755 "$post_update"
  fi

  # Now make the site git repo. Again, keep track of where we are. We will
  # return before we leave this function.
  local cwd=$(pwd)
  cd "$drupal_dir"
  git init --quiet
  if [ "$LONG_LIVE" = "y" ] && ! long_is_clone "$site"; then
    # Initialize from scratch
    long_log "Initializing git repo from scratch for live site." info
    git remote add bare "$git_dir" 

    files=$(find custom-civicrm libraries modules themes -type f)
    if [ -z "$files" ]; then
      printf "Site specific modules go here\n" > modules/README
      printf "Site specific themes go here\n" > themes/README
      printf "Site specific Civi templates and php code go here\n" > custom-civicrm/README
    fi

    printf "civicrm.settings.php\ndefault.settings.php\nfiles\nprivate\nsettings.php\nlocal.settings.php" \
      > "${drupal_dir}/.gitignore"
    git add custom-civicrm libraries modules themes .gitignore
    git commit --quiet -m "initial commit"
    git push --quiet bare master
  else
    if long_is_clone "$site"; then
      long_log "Initializing git repo for clone site." info
      # Clone site. Add remote from non-clone site.
      # Check if remote is clean.
      long_check_git_clean "${site:0: -5}"

      # Add remote.
      local live_git_dir="${dir:0: -5}/git"
      if [ ! -d "$live_git_dir" ]; then
        long_log "No bare git repo (%s). Maybe a clone on a dev site?" error "$live_git_dir"
      else
        git remote add live "$live_git_dir" 
        git pull live master
      fi
    else
      # Dev instance, add remote and pull 
      long_log "Initializing git repo for dev site." info
      local user=longshore
      local default_host=$LONG_DEFAULT_HOST
      long_log "Get host for site (%s)" info "$site"
      local host=$(ssh ${user}@${default_host}.mayfirst.org "/srv/longshore/bin/longshore site-info '$site'" | grep ^Sibling: | cut -d: -f2 | tr -d ' ')

      if [ -z "$host" ]; then
        long_log "Can't find the host" info
      else
        # Check if the remote site is clean and warn if it isn't (but keep going
        # to avoid half-completing this function).
        long_check_remote_git_clean "$site" "$host"    

        git remote add live "${user}@${host}.mayfirst.org:${dir}/git"
        git pull live master
      fi
    fi
  fi
  cd "$cwd"
  # Since it's a new repo, it should be clean.
  return 0
}

# Set the variable $LONG_SIBLING_CACHE to the sibling hosting the 
# given site.
long_set_site_sibling() {
  local site="$1"

  # Make sure our cache is up to date
  long_generate_sibling_cache

  LONG_SITE_SIBLING=$(grep "^${site}:" $LONG_SIBLING_CACHE | cut -d: -f2)
}

# Re-run the given command on the appropriate sibling if the site
# is hosted elsewhere. If the site is locally hosted, return 1
# and do nothing.
long_rerun_over_network() {
  local subcmd="$1"
  local site="$2"
  local me=$(hostname)

  long_set_site_sibling "$site"

  if [ -z "$LONG_SITE_SIBLING" ]; then
    # This could mean the site name was mis-typed.
    long_die "Can't determine where to run this command because site doesn't have sibling (%s)." 1 "$site"
  fi
  if [ "$LONG_SITE_SIBLING" = "$me" ]; then
    # Return 1 to indicate that we did not re-run over the network.
    return 1
  fi
  # Ensure the host is reachable.
  if ! long_is_host_reachable "${LONG_SITE_SIBLING}.mayfirst.org"; then
    long_die "The sibling I was trying to run this command on (%s) is not reachable." \
      1 "${LONG_SITE_SIBLING}.mayfirst.org"
  fi
  if [ -p /dev/fd/0 ]; then
    # Stdin is a pipe, don't allocate a terminal
    local t=
  else
    # Stdin is not a pipe, allocate a terminal in case we want this command to be
    # interactive.
    local t=-t
  fi
  ssh -q $t "${LONG_SITE_SIBLING}.mayfirst.org" "/srv/longshore/bin/longshore $@" 
  if [ "$?" != "0" ]; then
    long_log "Rerunning %s for site %s over network failed." error "$subcmd" "$site"
  fi
  # Return 0 to indicate that we did rerun over the network to avoid having
  # the calling script confuse an error message with not having run the
  # command.
  return 0

}

# Return 0 if it is reachable and 1 if it is not.
long_is_host_reachable() {
  # Try the host this many times.
  local tries=3

  local host="$1"
  local try=0
  while [ 1 ]; do
    if ping -q -c1 "$host" &>/dev/null; then
      # If successful, return 0/True
      return 0
    fi
    # Try up to $tries times before we give up
    if [ $try -ge $tries ]; then
      # Give up, host is down.
      return 1
    fi
    long_log "Failed attempt number %s when testing reachability of %s\n" \
      error "$try" "$host"
    # Pause for a second and continue loop.
    try=$(( $try + 1 ))
    sleep 1
  done
}

# Check if the provided name is only alpha-numeric. Used for validating
# proposed site names. Return 0 if it's only alphanumeric characters and 1 if
# it contains non-alphanumeric characters.
long_check_alpha_numeric() {
  echo "$1" | egrep '^[-0-9a-z]+$' > /dev/null
  return "$?"
}

# Provide a unique shortened database username if the provided username
# is longer than 16 characters.
long_sanitize_db_username() {
  local dbuser="$1"
  local len=$(echo -n "$dbuser" | wc -c)
  if [ "$len" -lt "17" ]; then
    LONG_DBUSER="$dbuser"
    return
  fi

  # Shorten the name to 14 characters
  dbuser=${dbuser:0:14}

  # Ensure it's unique by adding numbers to it.
  local index=
  local test=
  for index in 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20; do
    test="${dbuser}${index}"
    long_log "DB username is too long. Testing '%s'" info "$test"
    if ! cat "${LONG_SRV}"/services/sites/*/my.cnf | cut -d= -f2 | grep "$test" &> /dev/null; then
      long_log "DB username '%s' is available. Using it." info "$test"
      LONG_DBUSER="$test"
      return
    fi
  done
  long_die "Can't get unique database username for ${dbuser}."
}

long_clear_sibling_cache() {
  local sibling=
  rm -f "$LONG_SIBLING_CACHE" 
  for sibling in $LONG_SIBLINGS; do
    if ! long_is_host_reachable "${sibling}.mayfirst.org"; then
      long_log "The sibling I was trying to delete the cache on (%s) is not reachable. Continuing." \
        error "${sibling}.mayfirst.org"
    else
      ssh ${sibling}.mayfirst.org "rm -f '$LONG_SIBLING_CACHE'"
    fi
  done
}

long_generate_sibling_cache() {
  local target="$LONG_SIBLING_CACHE"
  local sibling=
  # See if our cache is less than one day old
  if [ -f "$target" ]; then
    mod_ts=$(stat -c %Y "$target")
    now=$(date +%s)
    diff=$(( $now - $mod_ts ))
    if [ "$diff" -lt "86400" ]; then
      # Less than a day old, return.
      return
    fi
  fi

  local temp=$(mktemp)

  # First get sites on this sibling.
  local me=$(hostname)
  local site=
  long_set_sites "$me" 
  long_log "Generating local site list." info
  for site in $LONG_SITES; do
    printf "%s:%s\n" "$site" "$me" >> "$temp"
  done

  # Now get sites on the other siblings.
  for sibling in $LONG_SIBLINGS; do
    long_log "Generating site list for %s." info "$sibling"
    if ! long_is_host_reachable "${sibling}.mayfirst.org"; then
      # If a sibling is not availale, it could be a temporary network 
      # error, in which case we should simply bail on regenerating the
      # cache because a stale cache is better than a cache that is missing
      # an entire sibling's servers. On the other hand, if the sibling is
      # offline and we are moving sites to a new server, then we want to
      # generate the cache without that sibling, because the sibling is
      # no longer hosting any sites. 
      #
      # So... by default, we assume that the problem is a temporary network
      # error, but we allow the user to set the:
      # LONG_FORCE_GENERATE_SIBLING_CACHE=1 environment variable to force the
      # regeneration of the cache.
      if [ "$LONG_FORCE_GENERATE_SIBLING_CACHE" -eq "1" ]; then
        long_log "The sibling I was trying to retrieve the cache for \
          (%s) is not reachable. Continuing without this sibling's sites
          because LONG_FORCE_GENERATE_SIBLING_CACHE is set to 1." \
          error "${sibling}.mayfirst.org"
      else
        long_log "The sibling I was trying to retrieve the cache for \
          (%s) is not reachable. Bailing on cache regeneration. If you \
          want to force the generation of the cache, set \
          LONG_FORCE_GENERATE_SIBLING_CACHE=1." \
          error "${sibling}.mayfirst.org"
        return
      fi
    else
      local sites=$(ssh ${sibling}.mayfirst.org /srv/longshore/bin/longshore site-list "$sibling")
      if [ "$?" -ne "0" ]; then
        long_log "The sibling I was trying to retrieve the cache for \
          (%s) Gave me a non-zero return code. That means when I pinged it \
          it worked, but when I ran ssh it failed. I'm bailing on cache \
          regeneration." \
          error "${sibling}.mayfirst.org"
        return
      fi
      for site in $sites; do
        printf "%s:%s\n" "$site" "$sibling" >> "$temp"
      done
    fi
  done

  sort "$temp" > "$target"
  rm "$temp"

  # Lastly, copy to the other siblings
  for sibling in $LONG_SIBLINGS; do
    long_log "Copying site list to %s." info "$sibling"
    scp -q "$target" "${sibling}.mayfirst.org:${target}"
  done
}

# Convenience function for quickly checking if site is mis-entered.
# Return 1 if it doesn't exist or 0 if it does.
long_check_site_exists() {
  long_set_site_sibling "$1"
  if [ -z "$LONG_SITE_SIBLING" ]; then
    return 1 
  fi
  return 0
}

# Get a list of all databases.
long_set_dbs() {
  local siblings="$1"
  local order_by_memory="$2"

  local me=$(hostname)

  if [ -z "$siblings" ]; then
    # Populate with all siblings, including the calling sibling.
    siblings="$me $LONG_SIBLINGS"
  fi
  local db=
  local dbs=
  local count=
  local id=
  local pid=
  local mem=
  local sibling=
  for sibling in $siblings; do
    if [ "$sibling" = "$me" ]; then
      dbhosts=$(ls "$LONG_SRV/services/databases" | grep -v 'lost+found')
      for dbhost in $dbhosts; do
        dbs=$(ls "$LONG_SRV/services/databases/$dbhost/mysql" | egrep -v '^(lost\+found|tc\.log|aria_|multi-master|ibdata1|ib_logfile0|ib_logfile1|mysql|performance_schema)' | tr "\n" " ")
        count=$(echo "$dbs" | wc -w)
        # Get Id for this db
        id=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Id}} "$dbhost")
        mem=0
        for pid in $(grep "$id" /proc/*/cgroup 2>/dev/null | cut -d/ -f3| sort | uniq); do
          mem=$(( $mem + $(( $(ps -h -p "$pid" -o rss) / 1024 )) ))
        done
        if [ "$order_by_memory" = "-m" ]; then
          # Put memory first.
          printf "%s:%s:%s:%s:%s\n" "$mem" "$count" "$sibling" "$db"  "$dbs"
        else
          # Put count first.
          printf "%s:%s:%s:%s:%s\n" "$count" "$sibling" "$db" "$mem"  "$dbs"
        fi
      done
    else
      if ! long_is_host_reachable "${sibling}.mayfirst.org"; then
        long_log "The sibling I was trying to get a list of dbs for (%s) is not reachable. Continuing." \
          error "${sibling}.mayfirst.org"
      else
        ssh "${sibling}.mayfirst.org" "/srv/longshore/bin/longshore db-list $sibling $order_by_memory" 
      fi
    fi
  done
}

# Set the site ID
long_set_site_id() {
  local site="$1"
  LONG_SITE_ID=$(docker $LONG_DOCKER_LOG_ARG inspect -f {{.Id}} "$site")
}

# Set a variable to hold all PIDs for this site
long_set_site_pids() {
  local site="$1"
  long_set_site_id "$site"
  LONG_SITE_PIDS=$(grep "$LONG_SITE_ID" /proc/*/cgroup 2>/dev/null | cut -d/ -f3| sort | uniq | tr "\n" " ")
}

# Calculate total memory in use by this site
long_set_site_memory() {
  local site="$1"
  long_set_site_pids "$site"
  LONG_SITE_MEMORY=0
  local mem=0
  local pid=
  local rss=
  for pid in $LONG_SITE_PIDS; do
    # -h means no header
    rss=$(ps -h -p "$pid" -o rss)
    if [ -n "$rss" ]; then
      mem=$(( $rss / 1024 ))
      LONG_SITE_MEMORY=$(( $LONG_SITE_MEMORY + $mem ))
    else
      LONG_SITE_MEMORY=0
    fi
  done
}

# Count the number of contacts in the given site
long_set_site_contacts_count() {
  local site="$1"
  local temp=$(mktemp)
  printf 'SELECT COUNT(*) FROM civicrm_contact WHERE is_deleted = 0' >> "$temp"
  LONG_SITE_CONTACTS_COUNT=$(long_execute_site_query "$site" "$temp" | tail -n1)
  rm "$temp"
}

# Count the number of recent logins on the given site. 
long_set_site_recent_logins_count() {
  local site="$1"
  local temp=$(mktemp)
  # Limit to last two weeks.
  printf 'SELECT COUNT(DISTINCT(uid)) FROM users WHERE uid != 0 AND name != "civicron" AND login > UNIX_TIMESTAMP() - 14 * 86400;' >> "$temp"
  LONG_SITE_RECENT_LOGINS_COUNT=$(long_execute_site_query "$site" "$temp" | tail -n1)
  rm "$temp"
}

# Count the total contributions on a given site for a given year (or current year). 
long_set_site_contributions_sum() {
  local site="$1"
  local year="$2"

  if [ -z "$year" ]; then
    year=$(date +%Y)
  fi

  local temp=$(mktemp)
  echo "SELECT SUM(total_amount) FROM civicrm_contribution c JOIN \
    civicrm_option_value ov ON c.contribution_status_id = ov.value JOIN \
    civicrm_option_group og ON ov.option_group_id = og.id \
    WHERE receive_date LIKE '$year-%' AND og.name = 'contribution_status' AND ov.name = 'Completed'" \
    >> "$temp"
  LONG_SITE_CONTRIBUTIONS_SUM=$(long_execute_site_query "$site" "$temp" | tail -n1)
  [ "$LONG_SITE_CONTRIBUTIONS_SUM" = "NULL" ] && LONG_SITE_CONTRIBUTIONS_SUM=0
  rm "$temp"
}

# Count the total contributions on a given site for a given year (or current year). 
long_set_site_emails_count() {
  local site="$1"
  local year="$2"

  if [ -z "$year" ]; then
    year=$(date +%Y)
  fi

  local temp=$(mktemp)
  echo "SELECT COUNT(*) FROM civicrm_mailing m JOIN \
    civicrm_mailing_recipients r ON m.id = r.mailing_id \
    WHERE scheduled_date LIKE '$year-%'" \
    >> "$temp"
  LONG_SITE_EMAILS_COUNT=$(long_execute_site_query "$site" "$temp" | tail -n1)
  rm "$temp"
}

# Check if web page contains the given text.
long_does_page_have_text() {
  local url="$1"
  local text="$2"
  local timeout="$3"

  # If no timeout is specified use 10 seconds as the default.
  if [ -z "$timeout" ]; then
    timeout=10
  fi

  if ! curl -s --max-time "$timeout" "$url" | grep "$text" >/dev/null; then
    return 1
  else
    return 0
  fi

}

# Set the phpmyadmin URL for all siblings
long_set_phpmyadmin_urls() {
  local sibling
  local url
  LONG_PHPMYADMIN_URLS="$LONG_PHPMYADMIN_URL"
  for sibling in $LONG_SIBLINGS; do
    url=$(ssh -q "${sibling}.mayfirst.org" "grep ^LONG_PHPMYADMIN_URL= $LONG_ETC/longshore.conf" | cut -d= -f2 | tr -d '"')
    LONG_PHPMYADMIN_URLS="${LONG_PHPMYADMIN_URLS} $url"
  done
}

# Check if site is online
long_is_site_reachable() {
  local site="$1"

  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    local protocol=https
  else
    local protocol=http
  fi
  local url="${protocol}://${site}.${LONG_DEFAULT_DOMAIN}"
  local text="Request new password via e-mail"
  if ! long_does_page_have_text "$url" "$text"; then
    return 1
  else
    return 0
  fi
}

# Truncate the sessions table to ensure nobody is logged in and to
# reduce backup size of drupal database.
long_clear_sessions() {
  local site="$1"
  temp=$(mktemp)
  printf "TRUNCATE TABLE sessions" > "$temp"
  long_execute_site_query "$site" "$temp"
  rm "$temp"
}

# Get the name of a container for it's ID
long_get_container_name() {
  local id="$1"
  LONG_CONTAINER_NAME=$(docker $LONG_DOCKER_LOG_ARG ps --filter "id=$id" | egrep -o ' [^ ]*\s*$' | tr -d ' ' | tail -n1)
}

# Generate DKIM keys
long_generate_dkim_key() {
  local domain="$1"
  local selector="$2"

  LONG_SITE_DKIM_TXT=
  long_log "Generating DKIM key for '%s' and '%s'" info "$domain" "$selector"
  if [ -z "$LONG_GENERATE_DKIM_CMD" ]; then
    long_die "LONG_GENERATE_DKIM_CMD is not defined. Please add it to your longshore.conf file."
  fi
  local out=$($LONG_GENERATE_DKIM_CMD "$domain" "$selector")
  if [ "$?" -ne "0" ]; then 
    long_log "Failed to generate DKIM (%s and %s)." error "$domain" "$selector"
    return
  fi
  # The txt is not suitable for inserting into a DNS record. It needs some cleanup. At the moment we get:
  # (Note line break).
  # default._domainkey      IN      TXT     ( "v=DKIM1; h=rsa-sha256; k=rsa; s=email; "
  #    "p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgJv0vEZGGap5E9B0UN3W4W6TAjj5s2iVnaQMGaRuC/b4n3jCi3uqM9/sFk4HuoMq2noRkC1hZ8lulPusblt/o8sFOMJpWBPwbYDA4V3Hc3Sekj0uClIUEGaruvJu9a+kWIBinUk45ReQ4hjYAvrkqmS0qruG6oCvAaV6oK0KgDQIDAQAB" )  ; ----- DKIM key default for livingcully
  # We need just the part in quotes, and rsa-sha256 is wrong, we just want sha256.
  # The echo $(echo) part removes the line break (replaces it with 2 spaces).
  # And lastly, urlencode the relevant characters (space, +, /). 
  LONG_SITE_DKIM_TXT=$(echo $(echo "$out" | cut -d'"' -f2 | sed "s/h=rsa-sha256/h=sha256/") | sed "s#  # #g" | sed "s# #%20#g" | sed "s#/#%2F#g" | sed "s#+#%2B#g" )
}

long_create_dkim_dns() {
  local fqdn="$1"
  local txt="$2"
  local api_login=pb-api-user
  local url="https://members.mayfirst.org/cp/api.php"
  local hosting_order_id=1000002
  local service_id=9
  local dns_ttl=600
  local red_api_password_path=~/.red-api-password
  local api_password=$([ -s "$red_api_password_path" ] && cat "$red_api_password_path")

  # Sanity checking.
  if [ "$LONG_LIVE" != "y" ]; then
    # Don't die, this isn't a fatal error.
    long_log "Not setting DNS in dev instance." info
    return
  fi
  exists=$(dig +short -t txt "$fqdn")
  if [ "$?" != 0 ]; then
    long_die "Error checking dns (%s). Output: %s" 1 "$fqdn" "$exists"
  fi
  
  [ -z "$api_password" ] && long_die "Please put your red api password in %s." 1 "$red_api_password_path"
  [ -z "$LONG_IP_ADDR" ] && long_die "The host IP address is not set in longshore.conf"

  declare -a post
  if [ -n "$exists" ]; then
    long_log "The DNS dkim record has already been created." info
    return
  else
    post=("action=insert" "output=text" "object=item" "set:service_id=${service_id}" "set:hosting_order_id=${hosting_order_id}" "set:dns_fqdn=${fqdn}" "set:dns_type=text" "set:dns_ttl=${dns_ttl}" "set:dns_sshfp_algorithm=0" "set:dns_sshfp_type=0" "set:dns_text=${txt}" "user_name=$api_login" "user_pass=$api_password" "output_format=text")
  fi

  out=$(curl --silent $(for i in "${post[@]}"; do echo --data "$i"; done) "$url")
  if [ "$?" -ne "0" ]; then
    long_die "Failed to use curl when setting the DNS entry."
  fi

  echo "$out" | grep '"is_error":0' > /dev/null

  if [ "$?" -ne "0" ]; then
    echo "$out"
    printf "Command: curl --silent --data-urlencode %s %s\n" "$post" "$url"
    long_die "Failed to create DNS record."
  fi
}

# Pull information from the PTP database to setup default
# info in the site database.
long_setup_org_info() {
  local site="$1"
  local url="https://${site}.${LONG_DEFAULT_DOMAIN}/"
  # Call externally to query the PTP database, not this sites database.
  # We have to call via the full longshore command because the site
  # may not be on the same server as the PTP site.
  local name=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=name")
  local email=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=email")
  local phone=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=phone")
  local state=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=state")
  local zip=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=zip")
  local address=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=address")
  local city=$(LONG_LOG_LEVEL=error "${LONG_SRV}/bin/longshore" site-drush ptp ptp-get-site-info "--url=$url --info=city")

  long_exec_drush_cmd "$site" "pbd-setup-org-info --email=$email '--name=$name' --state=$state '--phone=$phone' '--city=$city' '--zip=$zip' '--address=$address'"
}

# Add demo theme
long_add_demo_theme() {
  local site="$1"
  local themes="${LONG_SRV}/services/sites/${site}/drupal/themes"
  if [ ! -d "${themes}/demo" ]; then
    mkdir -p "$themes"
    cp -r "${LONG_SHARE}/themes/demo" "${themes}/"
    long_exec_drush_cmd "$site" "pbd-prepare-theme --name=demo --default"
  fi
}

long_clear_cache() {
  local site="$1"
  local cache="$2"
  if [ "$cache" == "all" -o "$cache" == "drush" ]; then
    long_exec_drush_cmd "$site" "cc all"
  fi
  if [ "$cache" == "all" -o "$cache" == "menu" ]; then
    long_exec_drush_cmd "$site" "php-eval '_civicrm_init(); CRM_Core_Invoke::rebuildMenuAndCaches();'"
  fi
  if [ "$cache" == "all" -o "$cache" == "files" ]; then
    long_exec_in_container "$site" "rm -rf \
      /var/www/powerbase/sites/default/files/css/* \
      /var/www/powerbase/sites/default/files/js/* \
      /var/www/powerbase/sites/default/files/civicrm/templates_c/en_US/*"
  fi
  if [ "$cache" == "all" -o "$cache" == "flood" ]; then
    temp=$(mktemp)
    printf 'TRUNCATE TABLE flood;' > "$temp"
    long_execute_site_query "$site" "$temp"
    rm "$temp"
  fi
}

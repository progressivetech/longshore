# This file should be sourced by all scripts. It contains
# shared functions

# Variables that can be set via the environment are:
# LONG_DRUSH_ARGS - to pass arbitrary args to all drush invocations,
#   such as --debug or -v
# LONG_YES - to bypass any prompts that this libraries handles
#   (that does not include drush prompts, so you may need to 
#   combine with LONG_DRUSH_ARGS=-y if you want to fully automate
#   a script).

# One liner for printing message and dying
# long_die $msg $exit_code $var $var
function long_die() {
  msg="$1"
  exit_code="$2"
  shift 2
  [ -z "$exit_code" ] && exit_code=1
  long_log "$msg" error "$@"
  exit "$exit_code"
}

# Return defined $long_usage_message and die 
function long_usage() {
  exit_code="$1"
  [ -z "$exit_code" ] && exit_code=1
  long_die "$long_usage_message" "$exit_code"
}

# Ensure the number of required arguments have been passed
# and if not, run long_usage (which will exit). Also, parse
# global arguments (like -f for force).
function long_check_args() {
  # The sub command is one argument that we don't count, so subtract 1 from 
  # the number of arguments passed.
  first_arg="$1"
  num_passed=$(( $2 - 1 ))
  num_required="$3"
  [ -z "$num_passed" ] && num_passed=0
  [ -z "$num_required" ] && num_required=0
  if [ "$first_arg" = "-h" ] || [ "$first_arg" = "--help" ]; then
    long_usage  
  fi 
  if [ "$num_passed" -lt "$num_required" ] ; then
    long_log "Not enough arguments passed. Expecting at least %s, received %s.\n" error "$num_required" "$num_passed"
    long_usage
  fi
}

# Given a site, set the ssh variable to empty if it should 
# be run locally or a working ssh command that connects to
# the appropriate frontend.
function long_set_ssh_command() {
  site="$1"
  host=$(hostname)
  frontend=$(ptp-get-frontend-for-site "$site")
  ssh=
  [ -n "$frontend" ] && [ "$host" != "$frontend" ] && ssh="ssh ${frontend}.mayfirst.org"
}

# Given a site, check if we should connect to a remote aegir frontend to run
# the given command that was called (in which case, make the connection and run
# the command) or run it locally. This function should be called by scripts
# that need to be run locally.
function long_rerun_over_network() { 
  site="$1"
  long_set_ssh_command "$site"
  # Return 0 (aka success) to indicate that we did
  # run the command over ssh
  if [ -n "$ssh" ]; then
    $ssh "$0" "$site" "$2" "$3"
    return 0
  fi
  # Return 1 (aka failure) to indicate that we didn't
  # rerun it over the network and the script should
  # proceed to run it locally.
  return 1
}

# Prompt the user with a given message ($1) and the question
# "Proceed? [Yn]" - set $reply variable to either y or n, properly
# parsing case and the default.
long_prompt() {
  msg=$1
  shift
  printf "${msg}\n" "$@"
  if [ "$LONG_YES" = "1" ]; then
    printf " Automatically proceeding without prompt.\n"
    reply=y
    return
  fi
  read -p "Proceed? [Yn] "
  reply=n
  if [ -z "$REPLY" ] || [ "$REPLY" == "Y" ] || [ "$REPLY" == "y" ]; then
    reply=y
  fi
}

# Either output a message to standard error or send it by email
# depending on whether we are running from a cron job or not
long_debug() {
  msg="$1"
  subject="$2"
  pid="$!"
  if grep -q cron /proc/"$pid"/cmdline &> /dev/null; then
    echo "$msg" | mail -s "$subj" "$LONG_DEBUG_EMAIL"
  else
    echo "$subject" >&2
    echo "$msg" >&2
  fi
  exit 1
}

# Check if a conatiner with the given name exists or not.
# Return 0 if it exists and 1 if it doesn't.
long_container_exists() {
  long_container_or_image_exists "$1"
}

# Inspect seems to work for both containers and images.
long_container_or_image_exists() {
  name="$1"
  [ -z "$name" ] && return 1
  # This command returns 1 if the container doesn't exist and 0 if it does.
  docker inspect "$name" 2>/dev/null 1>/dev/null
  return "$?"
}

# Check if a conatiner with the given name is running or not.
# Return 0 if it is running and 1 if it isn't.
long_container_running() {
  name="$1"
  [ -z "$name" ] && return 1
  running=$(docker inspect -f {{.State.Running}} "$name")
  [ "$running" = "true" ] && return 0
  return 1
}

# Check if an image with the given name exists.
# Return 0 if it exists and 1 if it doesn't.
long_image_exists() {
  long_container_or_image_exists "$1"
}

# Generate a my.cnf file with the given info
long_generate_my_cnf() {
  dir="$1"
  password="$2"
  port="$3"
  printf "[client]\nuser=root\npassword=%s\nport=%s\nhost=127.0.0.1\n" "$password" "$port" > "$dir"/my.cnf
}

# Generate a random password
long_pwgen() {
  # Excluding characters that commonly cause problems. Sigh.
  password=$(hexdump -e '"%_p"' /dev/urandom | tr -d '[:punct:]\n' | head -c 25)
}

# Output logging info based on log level
# long_log $msg $log_level $var $var
# log levels: info, error, critical
long_log() {
  msg="$1"
  log_level="$2"
  shift 2
  out=n
  # Always output critical
  if [ "$log_level" = "critical" ]; then
    out=y
  fi
  # Output error if we are set to info or error
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "info" ];  then
    out=y
  fi
  if [ "$log_level" = "error" -a "$LONG_LOG_LEVEL" = "error" ];  then
    out=y
  fi
  # Output info if we are set to info
  if [ "$log_level" = "info" -a "$LONG_LOG_LEVEL" = "info" ];  then
    out=y
  fi
  if [ "$out" = "y" ]; then
    printf "$msg\n" "$@"
  fi
}

# Save the generic tls configuration for all sites
long_create_nginx_tls_conf() {
  tls_template="${LONG_SHARE}/templates/nginx-tls.conf"
  tls_target="$LONG_NGINX_TLS_PATH"
  cat "$tls_template" | \
    sed \
    -e "s:LONG_TLS_KEY_PATH:$LONG_TLS_KEY_PATH:" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    -e "s:LONG_X509_CERT_PATH:$LONG_X509_CERT_PATH:" \
    -e "s:LONG_DH_PARAM_PATH:$LONG_DH_PARAM_PATH:" \
    > "$tls_target"
}

# save the phpmyadmin nginx configuration file
long_create_nginx_phpmyadmin_conf() {
  port="$1"
  template="${LONG_SHARE}/templates/nginx-phpmyadmin.conf"
  target="${LONG_NGINX_SITES_ENABLED}/phpmyadmin.conf"
  LONG_SITE_URL="$LONG_PHPMYADMIN_URL"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    LONG_TLS_OR_NOT="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect phpmyadmin "$LONG_SITE_URL"
  else
    LONG_TLS_OR_NOT="listen ${LONG_IP_ADDR}:80"
  fi
  LONG_CGI_PORT="$port"
  cat "$template" | \
    sed \
    -e "s:LONG_TLS_OR_NOT:$LONG_TLS_NOT:" \
    -e "s:LONG_SITE_URL:$LONG_SITE_URL:" \
    -e "s:LONG_CGI_PORT:$LONG_CGI_PORT:" \
    > "$target"
}

# Pass the short site name as first argument and the full
# URL as the second.
long_create_nginx_redirect() {
  site="$1"
  LONG_SITE_URL="$2"
  redirect_template="${LONG_SHARE}/templates/nginx-redirect-https.conf"
  redirect_target="${LONG_NGINX_SITES_ENABLED}/${site}-redirect.conf"
  cat "$redirect_template" | \
    sed \
    -e "s#LONG_SITE_URL#$LONG_SITE_URL#" \
    -e "s#LONG_IP_ADDR#$LONG_IP_ADDR#" \
    > "$redirect_target"
}

# Save an nginx server configuration file
long_create_nginx_site_conf() {
  site="$1"
  platform="$2"
  port="$3"

  template="${LONG_SHARE}/templates/nginx-site.conf"
  target="${LONG_NGINX_SITES_ENABLED}/${site}.conf"
  LONG_SITE_URL="${site}.${LONG_DEFAULT_DOMAIN}"
  if [ -f "$LONG_NGINX_TLS_PATH" ]; then
    LONG_TLS_OR_NOT="include $LONG_NGINX_TLS_PATH;"
    long_create_nginx_tls_conf
    long_create_nginx_redirect "$site" "$LONG_SITE_URL"
  else
    LONG_TLS_OR_NOT="listen ${LONG_IP_ADDR}:80"
  fi
  LONG_ACCESS_LOG="${site}.access.log"
  LONG_WEB_ROOT="/var/www/html/${platform}"
  LONG_PHP_ROOT="$LONG_WEB_ROOT"
  LONG_CGI_PORT="$port"

  cat "$template" | \
    sed \
    -e "s#LONG_LISTEN_443#$LONG_LISTEN_443#" \
    -e "s#LONG_ACCESS_LOG#$LONG_ACCESS_LOG#" \
    -e "s#LONG_SITE_URL#$LONG_SITE_URL#" \
    -e "s#LONG_WEB_ROOT#$LONG_WEB_ROOT#" \
    -e "s#LONG_PHP_ROOT#$LONG_PHP_ROOT#" \
    -e "s#LONG_CGI_PORT#$LONG_CGI_PORT#" \
    > "$target"
}

# Return 0 if it's the latest and 1 if it's not and 2 for an error.
long_phpmyadmin_is_latest() {
  # Check version installed
  installed=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/README" ]; then
    installed=$(head "${LONG_SRV}/services/phpmyadmin/src/README" | grep '^Version' | cut -d\  -f2)
  else
    # It's not installed at all, that means not the latest.
    return 1 
  fi

  [ -z "$installed" ] && return 2 

  latest=
  if [ -f "${LONG_SRV}/services/phpmyadmin/src/version_check.php" ]; then
    latest=$(cd "${LONG_SRV}/services/phpmyadmin/src/" && php version_check.php | tr -d '{}"' | cut -d, -f1 | cut -d: -f2)
  else
    # Something is broken if we don't have this file
    return 2 
  fi

  [ -z "$latest" ] && return 2 

  [ "$latest" = "$installed" ]  && return 0
  return 1
}

# This variable containing the names of all database containers
long_db_containers() {
  long_db_containers=$(ls "${LONG_SRV}/services/databases/")
}

# Create if necessary the given image
# first argument is tag, second is path to docker directory
long_image_create() {
  tag="$1"
  path="$2"
  if ! long_image_exists "$tag"; then
    long_log "Creating image (%s)" info "$tag"
    if [ "$tag" = "ptp-base" ]; then
      # This is a special condition
      long_image_create_base
    else
      docker build -t "$tag" "$path"
    fi
  fi
}

# Create the base image
long_image_create_base() {
  long_log "Creating base image" info
  sudo /usr/local/sbin/longshore-create-base-image
}

# Delete, if necessary, the image
long_image_delete() {
  tag="$1"
  if long_image_exists "$tag"; then
    long_log "Deleting  image (%s)" info "$tag"
    docker rmi "$tag"
  fi
}

# Create (if necessary) and start (if necessary) a given container
long_container_up() {
  type="$1"
  name="$2"

  # phpmyadmin will be called with just the type variable set.
  # In these cases, we use the type as the name - since we only have one
  # one phpmyadmin container.
  label="$name"
  [ -z "$label" ] && label="$type"
  if ! long_container_exists "$label"; then
    long_log "Creating container (%s)" info "$label"
    longshore container-create "$type" "$name"
  fi
  if ! long_container_running "$label"; then
    long_log "Starting container (%s)" info "$label"
    docker start "$label"
  fi
}

# Stop (if necessary) and delete (if necessary) the named container
long_container_destroy() {
  name="$1"
  if long_container_exists "$name"; then
    if long_container_running "$name"; then
      long_log "Stopping container (%s)" info "$name"
      docker stop "$name" 
    fi
    long_log "Removing container (%s)" info "$name"
    docker rm "$name" 
  fi
}

# Reload nginx to pickup new configurations
long_nginx_reload() {
  sudo /etc/init.d/nginx reload
}

# Get the port for this mysql container, or assign a new one.
long_get_mysql_port() {
  name="$1"
  dir="${LONG_SRV}/services/databases/${name}"
  if [ -f "$dir/my.cnf" ]; then
    port=$(grep port "${dir}/my.cnf" | cut -d= -f2)
  else
    # If we don't already have a .my.cnf file, find the next available port.
    last_port=$(grep port= "${LONG_SRV}/services/databases/*/my.cnf" 2>/dev/null | cut -d= -f2 | sort -n | tail -n 1)
    if [ -z "$last_port" ]; then
      port="$LONG_MYSQL_START_PORT"
    else
      port=$(( $last_port + 1 ))
    fi
  fi
}

# Get the port for this php container, or assign a new one.
long_get_php_port() {
  name="$1"
  if [ "$name" = "phpmyadmin" ]; then
    envdir="${LONG_SRV}/services/phpmyadmin/env"
  else
    envdir="${LONG_SRV}/services/sites/${name}/env"
  fi
  if [ -f "${envdir}/PORT" ]; then
    port=$(cat "${envdir}/PORT")
  else
    # If we don't already have a PORT file, find the next available port.
    last_port=$(cat "${LONG_SRV}/services/phpmyadmin/env/PORT" "${LONG_SRV}/services/*/env/PORT" 2>/dev/null | sort -n | tail -n1)
    if [ -z "$last_port" ]; then
      port="$LONG_PHP_START_PORT"
    else
      port=$(( $last_port + 1 ))
    fi
    mkdir -p "$envdir"
    echo "$port" > "${envdir}/PORT"
  fi
}

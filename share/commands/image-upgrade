#!/bin/bash

long_usage_message="usage: $(basename $0) image-upgrade <type>
Check all images for upgrades. If there are upgrades, force the
rebuild of the image.

Arguments
  <type> - The image type you want to upgrade (ptp-mysql, etc.) or '--all'
    to create all images"

long_check_args "$2" "$#" 1

itypes="$2"
possible_itypes="my-jessie ptp-mysql ptp-php ptp-powerbase"

if [ "$itypes" = "--all" ]; then
  itypes="$possible_itypes"
fi

for itype in $itypes; do
  if ! echo "$possible_itypes" | egrep "(^| )$itype( |\$)" > /dev/null; then
    long_die "Unknown image type %s." 1 "$itype"
  fi
done

for itype in $itypes; do
  long_log "Checking for upgrade in %s image." info "$itype"
  packages=$(docker run --name upgrade "$itype" bash -c 'apt-get -qq update && apt-get -qq -s dist-upgrade' | awk '/^Inst/ { print $2 }')
  # Output to /dev/null to avoid docker printing the name of container
  # we just deleted.
  docker rm upgrade > /dev/null
  if [ -n "$packages" ]; then
    # Re-build the image
    long_log "Found packages needing to be upgraded in %s image; rebuilding." info "$itype"
    LONG_FORCE=1
    long_create_image "$itype"
  fi
done

# Remove left over images.
long_log "Removing dangling images." info
danglers=$(docker images -q --filter "dangling=true")
if [ -n "$danglers" ]; then
  for dangler in $danglers; do
    # We don't care about errors in images that could not be deleted because they are in use.
    docker rmi "$dangler" 2>&1 | grep -v "conflict: unable to delete"
  done
fi

#!/bin/bash

long_usage_message="usage: $(basename $0) <type> [<name>] [<db>] [<platform>]
Create a container. 

Arguments
  <type> - The container type you want to create (site, mysql, phpmyadmin) 
  <name> - The name to give the container. Optional for phpmyadmin not for
  site or db.
  <db> - For site containers, specify the database to link it to.
  <platform> - For site containers, specify the platform to use."

long_check_args "$2" "$#" 1

ctype="$2"
name="$3"
db="$4"
platform="$5"

if [ -z "$name" ]; then
  if [ "$ctype" = "phpmyadmin" ]; then
    name="$ctype"
  else
    long_die "Containers of this type need a name passed as second argument."
  fi
fi

# Stop and Delete the container if force is specified.
if [ "$LONG_FORCE" = 1 ]; then
  long_container_destroy "$name"
fi

# If the container already exists, then we are done. 
if long_container_exists "$name"; then
  return
fi

# Create a mysql container.
if [ "$ctype" = "mysql" ]; then

  dir="${LONG_SRV}/services/databases/${name}"

  # Use our password generation utility which uses /dev/urandom.
  # long_pwgen will assign a new password to the variable $password.
  password=
  long_pwgen

  # Get the port number. Each MySQL container is assigned a unique port
  # on the host.
  port=
  long_get_mysql_port

  # Make sure our base directory and a mysql sub directory exists.
  # Our my.cnf file will go in ${dir}/my.cnf and be mounted in the host
  # in /mnt/my.cnf and ${dir}/mysql will get mounted at /var/lib/mysql.
  mkdir -p "${dir}/mysql"
  mkdir -p "${dir}/logs"
  long_generate_my_cnf "$dir" "$password" "$port"
  docker create --name "$name" \
    -v "${dir}/mysql":/var/lib/mysql \
    -v "${dir}/my.cnf:/root/.my.cnf" \
    -v "${dir}/logs:/var/log/mysql" \
    -e "LONG_LIVE=$LONG_LIVE" \
    -p "$LONG_IP:${port}:3306" \
    ptp-mysql:latest mysqld

elif [ "$ctype" = "phpmyadmin" ]; then

  dir="${LONG_SRV}/services/phpmyadmin"
  # Make sure we have our base directories
  mkdir -p "$dir/src"

  # Create the server.list file with all db servers on this host
  long_db_containers
  echo "$long_db_containers" > "${dir}/src/servers.list"

  # FIXME - This is temporary while we are supporting both longshore and 
  # aegir. The phpmyadmin instance has to connect to the aegir servers 
  # too.
  for server in $(ls -d /var/aegir/platforms/*-ourpowerbase-d7-c4.5 | sed 's/-ourpowerbase-d7-c4\.5$//' | cut -d/ -f5); do
    # On dev servers - master is used for localhost
    if [ "$server" = "master" ]; then
      continue
    else
      server="${server}.mayfirst.org"
    fi
    echo "$server" >> "${dir}/src/servers.list"
  done

  # Create the --link argument
  link=
  for db in $long_db_containers; do
    link="$link --link $db:$db"
  done

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  port=
  long_get_php_port phpmyadmin

  publish="-p 127.0.0.1:$port:9000"

  # Copy in the config.inc.php.sample file with blowfish secret
  password=
  long_pwgen
  cat ${LONG_SHARE}/templates/phpmyadmin.config.inc.php.sample | sed "s/BLOWFISHSECRET/$password/" \
    > "${dir}/src/config.inc.php" 

  # Create nginx configuration
  long_create_nginx_phpmyadmin_conf "$port"

  # Docker
  docker create --name phpmyadmin \
    -v "${dir}/src:/var/www/phpmyadmin" \
    -v "${LONG_SRV}/platforms:/var/www/html" \
    $link \
    $publish \
    ptp-php:latest php5-fpm 

elif [ "$ctype" = "site" ]; then

  # Sanity check - make sure platform exists 
  if [ ! -d "${LONG_SRV}/platforms/${platform}" ]; then
    long_die "That platform doesn't seem to exist (%s)." "$platform"
  fi

  # Ensure that the database container exists. 
  longshore container-create mysql "$db"

  # Build out directories. Create the minimal amount of directories and
  # let Drupal and CiviCRM create the rest.
  dir="${LONG_SRV}/services/sites/$name"
  creates="backup drupal drupal/custom-civicrm
    drupal/custom-civicrm/extensions drupal/custom-civicrm/php
    drupal/custom-civicrm/templates drupal/files
    drupal/files/civicrm drupal/files/civicrm/ConfigAndLog
    drupal/files/civicrm/custom drupal/files/civicrm/persit
    drupal/files/civicrm/templates_c drupal/files/civicrm/upload
    drupal/private drupal/modules drupal/themes drupal/libraries"
  for create in $creates; do
    mkdir -p "${dir}/$create"
  done

  # Certain directories should not be accessible by the web user, only 
  # by the user running the PHP application.
  # See https://civicrm.org/advisory/civi-sa-2014-001-risk-information-disclosure
  not_web_accessible="drupal/files/civicrm/ConfigAndLog
    drupal/files/civicrm/templates_c drupal/files/civicrm/upload"
  # Prohibit web access by removing other access. Only the user and the
  # group owners will be able to access the files. And only the owner will
  # be able to write to them.
  for foo in $not_web_accessible; do
    # We only need to make this change at the top level - no need for
    # recursive.
    chmod o-rwx "${dir}/${foo}" 
    chmod g-w "${dir}/${foo}" 
  done

  # One more directory should be readable by the web user, but the web
  # user should not be able to get a directory listing. We can do that
  # by removing execute privileges, but keeping read privileges.
  chmod o-x "${dir}/drupal/files/civicrm/contribute"

  # Now that the right modes are set, chown the files to the right users. 
  web_writable="drupal/files drupal/private"
  for foo in $web_writable; do
    # Maintain group ownership by the longshore user so we can read the
    # files from the host for convenience and trouble-shooting.
    sudo chown -R longshore-php:longshore "${dir}/${foo}"
  done

  # We have to publish the port to the host so nginx can communicate
  # with it. Each PHP container has to have a unique port.
  port=
  long_get_php_port "$name" 

  publish="-p 127.0.0.1:$port:9000"

else

  long_die "I don't know how to make a container of that type (%s)." 1 "$ctype"

fi

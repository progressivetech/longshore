#!/bin/bash

long_usage_message="usage: $(basename $0)
Initialize a server to use longshore."
long_check_args "$2" "$#"

# A few sanity checks
user=$(whoami)
[ "$user" != "root" ] && long_die "You must run this command as root."

[ ! -e /srv/longshore/bin/longshore ] && long_die "You must have longshore installed in /srv/longshore/bin/longshore"

install=
if ! dpkg -l docker.io 2>/dev/null | grep ^ii >/dev/null; then
  if ! dpkg -l lxc-docker 2>/dev/null | grep ^ii >/dev/null; then
    install=docker.io
  fi
fi

if ! dpkg -l sudo 2>/dev/null | grep ^ii >/dev/null; then
  install="$install sudo"
fi

if ! dpkg -l nginx 2>/dev/null | grep ^ii >/dev/null; then
  install="$install nginx"
fi

if ! dpkg -l debootstrap 2>/dev/null | grep ^ii >/dev/null; then
  install="$install debootstrap"
fi

if ! dpkg -l drush 2>/dev/null | grep ^ii >/dev/null; then
  install="$install drush"
fi

if ! dpkg -l wget 2>/dev/null | grep ^ii >/dev/null; then
  install="$install wget"
fi

if ! dpkg -l mysql-client 2>/dev/null | grep ^ii >/dev/null; then
  install="$install mysql-client"
fi
if [ -n "$LONG_TLS_KEY_PATH" ]; then
  if ! dpkg -l openssl 2>/dev/null | grep ^ii >/dev/null; then
    install="$install openssl"
  fi
fi

if [ -n "$install" ]; then
  long_prompt "Installing $install"
  [ "$reply" = "y" ] && apt-get update && apt-get install $install
fi

users=
if ! getent passwd longshore > /dev/null; then
  users=longshore:5000
fi

if ! getent passwd longshore-php > /dev/null; then
  users="$users longshore-php:5001"
fi

if [ -n "$users" ]; then
  long_prompt "Installing the following users/UIDs:%s" "$users."
  if [ "$reply" = "y" ]; then
    for user in $users; do
      username=$(echo "$user" | cut -d: -f1)
      if [ "$username" = "longshore" ]; then
        adduser --disabled-password --gecos "Longshore User" "$username"
      else
        uid=$(echo "$user" | cut -d: -f2)
        getent group "$username" > /dev/null || groupadd "$username" -g "$uid"
        useradd -u "$uid" -g "$uid" "$username"
      fi
    done
  fi
fi

if ! groups longshore | grep docker >/dev/null; then
	long_prompt "Adding longshore user to the docker group"
	adduser longshore docker
fi
longshore_sudo_file="${LONG_SHARE}/templates/longshore.sudoers"
longshore_sudo_file_target=/etc/sudoers.d/longshore

if [ ! -f "$longshore_sudo_file_target" ] || ! diff "$longshore_sudo_file" "$longshore_sudo_file_target" > /dev/null; then
  long_prompt "Granting longshore user sudo rights to chown files"
  if [ "$reply" = "y" ]; then
    cp "$longshore_sudo_file" "$longshore_sudo_file_target"
  fi
fi

bash_profile_path=~longshore/.profile
touch "$bash_profile_path"
if ! grep 'PATH="/srv/longshore/bin' "$bash_profile_path" > /dev/null; then
  long_prompt "Adding /srv/longshore/bin to PATH"
  if [ "$reply" = "y" ]; then
    echo 'PATH="/srv/longshore/bin:$PATH"' > "$bash_profile_path"
    chown longshore:longshore "$bash_profile_path"
  fi
fi

# If this is the first time we have run - we may have checked out these files
# as root so we should chown them.
if ! stat /srv/longshore/bin | grep "Uid" | grep longshore >/dev/null; then
  long_prompt "Chown'ing files"
  if [ "$reply" = "y" ]; then
    chown -R longshore:longshore /srv/longshore/bin /srv/longshore/share \
      /srv/longshore/etc /srv/longshore/.git /srv/longshore/README.md
    chown longshore:longshore /srv/longshore
  fi
fi

# Ensure the file that needs to be run as sudo is installed and up-to-date
source="${LONG_SHARE}/templates/longshore-create-base-image" 
target="/usr/local/sbin/longshore-create-base-image"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating longshore-create-base-image"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
    chmod 755 "$target"
  fi
fi

# Ensure that our tweak to nginx to allow longer server names is in place.
source="${LONG_SHARE}/templates/server-names-hash-bucket-size.conf"
target="/etc/nginx/conf.d/server-names-hash-bucket-size.conf"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating server-names-hash-bucket-size.conf"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
    chmod 644 "$target"
  fi
fi

# Ensure that docker group owns /etc/nginx/sites-enabled and it is writable 
# so any docker enabled user can write to it..
group_owner=$(stat -c '%G' /etc/nginx/sites-enabled)
mode=$(stat -c '%A' /etc/nginx/sites-enabled)
if [ "$group_owner" != "docker" ]; then
  long_prompt "Chgrp'ing nginx sites-enabled directory to docker group."
  if [ "$reply" = "y" ]; then
    chown root:docker /etc/nginx/sites-enabled 
  fi
fi
if [ "$mode" != "drwxrwxr-x" ]; then
  long_prompt "Chmod'ing nginx sites-enabled directory to be group writable."
  if [ "$reply" = "y" ]; then
    chmod 0775 /etc/nginx/sites-enabled 
  fi
fi

# Setup the data directories and properly chown them
dirs="services services/phpmyadmin services/phpmyadmin/src services/phpmyadmin/env services/databases services/sites"
makedirs=
for dir in $dirs; do
  if [ ! -d "${LONG_SRV}/${dir}" ]; then
    makedirs="$makedirs $dir"
  fi
done
    
if [ -n "$makedirs" ]; then
  long_prompt "Making $makedirs"
  if [ "$reply" = "y" ]; then
    for makedir in $makedirs; do
      mkdir -p "${LONG_SRV}/${makedir}"
      chown longshore:longshore "${LONG_SRV}/${makedir}"
    done
  fi
fi

# Set phpmyadmin symlink for nginx to work properly on the host
if [ ! -h /var/www/phpmyadmin ] || [[ $(readlink /var/www/phpmyadmin) != "${LONG_SRV}/services/phpmyadmin/src" ]]; then
  long_prompt "Create phpmyadmin symlink"
  if [ "$reply" = "y" ]; then
    if [ -h /var/www/phpmyadmin ]; then
      rm -f /var/www/phpmyadmin;
    fi
    if [ -f /var/www/phpmyadmin ]; then
      long_die "There seems to be a file or directory in /var/www/phpmyadmin that should be moved by hand."
    fi
    ln -s "${LONG_SRV}/services/phpmyadmin/src" /var/www/phpmyadmin
  fi
fi

# Set platforms symlink for nginx to work properly on the host
if [ ! -h /var/www/powerbase ] || [[ $(readlink /var/www/powerbase) != "${LONG_SRV}/platforms" ]]; then
  long_prompt "Create nginx platforms symlink"
  if [ "$reply" = "y" ]; then
    if [ -h /var/www/powerbase ]; then
      rm -f /var/www/powerbase;
    fi
    if [ -f /var/www/powerbase -o -d /var/www/powerbase ]; then
      long_die "There seems to be a file or directory in /var/www that should be moved by hand."
    fi
    ln -s "${LONG_SRV}/platforms" /var/www/powerbase
  fi
fi
# Setup tls if necessary
if [ -n "$LONG_TLS_KEY_PATH" ]; then
  if [ -z "$LONG_X509_CERT_PATH" -o -z "$LONG_DH_PARAM_PATH" -o -z \
    "$LONG_NGINX_TLS_PATH" ]; then
    long_die "If you want https support, you have define LONG_TLS_KEY_PATH, \
      LONG_x509_CERT_PATH, LONG_DH_PARAM_PATH, and LONG_NGINX_TLS_PATH \
      in longshore.conf"
  fi
  if [ ! -f "$LONG_TLS_KEY_PATH" ]; then
    long_die "Please manually copy the key file to %s" 1 "$LONG_TLS_KEY_PATH"
  fi
  if [ ! -f "$LONG_X509_CERT_PATH" ]; then
    long_die "Please manually copy the crt file to %s" 1 "$LONG_X509_CERT_PATH"
  fi
  if [ ! -f "$LONG_DH_PARAM_PATH" ]; then
    long_prompt "Create dhparams"
    if [ "$reply" = "y" ]; then
      openssl dhparam -out "$LONG_DH_PARAM_PATH" 4096
    fi
  fi
  # Touch and fix ownership for tls.conf file
  touch "$LONG_NGINX_TLS_PATH"
  chown longshore:longshore "$LONG_NGINX_TLS_PATH"
fi

# Set autocomplete if necessary
longshore_config_path=~longshore/.config
bash_completion_path="${longshore_config_path}/bash_completion.d"
if [ ! -d "$bash_completion_path" ] || [ ! -f "${bash_completion_path}/longshore" ]; then
  long_prompt "Create bash_completion file for longshore."
  if [ "$reply" = "y" ]; then
    if [ ! -d "$longshore_config_path" ]; then
      mkdir -p "$longshore_config_path" && chown longshore:longshore "$longshore_config_path"
    fi
    if [ ! -d "$bash_completion_path" ]; then
      mkdir -p "$bash_completion_path" && chown longshore:longshore "$bash_completion_path"
    fi
    ln -s "${LONG_SHARE}/bash-completion/longshore" "${bash_completion_path}/longshore"
    chown --no-dereference longshore:longshore "${bash_completion_path}/longshore"
  fi
fi

# Ensure auto-complete is enabled in ~/.profile
if ! grep '~/.config/bash_completion.d/' "$bash_profile_path" > /dev/null; then
   long_prompt "Ensure bash completion is enabled."
  if [ "$reply" = "y" ]; then
    echo 'for file in $(find ~/.config/bash_completion.d/ -type f); do' >> "$bash_profile_path"
    echo '  source "$file"' >> "$bash_profile_path"
    echo 'done' >> "$bash_profile_path"
  fi
fi

#!/bin/bash

long_usage_message="usage: $(basename $0)
Initialize a server to use longshore."
long_check_args "$2" "$#"

# A few sanity checks
user=$(whoami)
[ "$user" != "root" ] && long_die "You must run this command as root."

[ ! -e /srv/longshore/bin/longshore ] && long_die "You must have longshore installed in /srv/longshore/bin/longshore"

[ -z "$LONG_HOST_USER" ] && long_die "You must have LONG_HOST_USER set in longshore.conf"

# Define packages we need to have installed.
install=
wants="sudo nginx debootstrap wget dnsutils mariadb-client \
  composer nodejs parallel curl"
if [ -n "$LONG_TLS_KEY_PATH" ]; then
  wants="$wants openssl"
fi

for want in $wants; do
  if ! dpkg -l "$want" 2>/dev/null | grep ^ii >/dev/null; then
    install="$install $want"
  fi
done

if [ -n "$install" ]; then
  long_prompt "Installing $install"
  [ "$reply" = "y" ] && apt-get update && apt-get install $install
fi

users=
if ! getent passwd "$LONG_HOST_USER" > /dev/null; then
  users="$LONG_HOST_USER:5000"
fi

if ! getent passwd longshore-php > /dev/null; then
  users="$users longshore-php:5001"
fi

if [ -n "$users" ]; then
  long_prompt "Installing the following users/UIDs:%s" "$users."
  if [ "$reply" = "y" ]; then
    for user in $users; do
      username=$(echo "$user" | cut -d: -f1)
      if [ "$username" = "$LONG_HOST_USER" ]; then
        adduser --disabled-password --gecos "Longshore User" "$username"
      else
        uid=$(echo "$user" | cut -d: -f2)
        getent group "$username" > /dev/null || groupadd "$username" -g "$uid"
        useradd -u "$uid" -g "$uid" "$username"
      fi
    done
  fi
fi

if ! groups "$LONG_HOST_USER" | grep docker >/dev/null; then
	long_prompt "Adding longshore host user to the docker group"
	adduser "$LONG_HOST_USER" docker
fi
longshore_sudo_file=$(mktemp)
cat "${LONG_SHARE}/templates/longshore.sudoers" | \
  sed "s/LONG_HOST_USER/$LONG_HOST_USER/g" > \
  "$longshore_sudo_file"
longshore_sudo_file_target=/etc/sudoers.d/longshore

if [ ! -f "$longshore_sudo_file_target" ] || ! diff "$longshore_sudo_file" "$longshore_sudo_file_target" > /dev/null; then
  long_prompt "Granting longshore host user sudo rights to chown files"
  if [ "$reply" = "y" ]; then
    cp "$longshore_sudo_file" "$longshore_sudo_file_target"
  fi
fi

# If this is the first time we have run - we may have checked out these files
# as root so we should chown them.
if ! stat /srv/longshore/bin | grep "Uid" | grep "$LONG_HOST_USER" >/dev/null; then
  long_prompt "Chown'ing files"
  if [ "$reply" = "y" ]; then
    chown -R "${LONG_HOST_USER}:${LONG_HOST_USER}" /srv/longshore/bin /srv/longshore/share \
      /srv/longshore/etc /srv/longshore/.git /srv/longshore/README.md
    chown "${LONG_HOST_USER}:${LONG_HOST_USER}" /srv/longshore
  fi
fi

# Ensure cron job to preserver premissions for backup is installed and up-to-date
source="${LONG_SHARE}/templates/longshore-fix-perms" 
target="/etc/cron.d/longshore-fix-perms"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating longshore-fix-perms"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
  fi
fi

# Ensure cron job to clear template cache is installed and up-to-date
source="${LONG_SHARE}/templates/longshore-clear-template-cache" 
target="/etc/cron.d/longshore-clear-template-cache"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating longshore-clear-template-cache"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
  fi
fi


# Ensure that our tweak to nginx to allow longer server names is in place.
source="${LONG_SHARE}/templates/server-names-hash-bucket-size.conf"
target="/etc/nginx/conf.d/server-names-hash-bucket-size.conf"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating server-names-hash-bucket-size.conf"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
    chmod 644 "$target"
  fi
fi

# Ensure that our tweak to nginx to allow longer client headers in in place.
source="${LONG_SHARE}/templates/large-client-header-buffers.conf"
target="/etc/nginx/conf.d/large-client-header-buffers.conf"
if  [ ! -f "$target" ] || ! diff -q "$source" "$target" >/dev/null; then
  long_prompt "Updating large-client-header-buffers.conf"
  if [ "$reply" = "y" ]; then
    cp "$source" "$target" 
    chmod 644 "$target"
  fi
fi
# Ensure that docker group owns /etc/nginx/sites-enabled and it is writable 
# so any docker enabled user can write to it..
group_owner=$(stat -c '%G' /etc/nginx/sites-enabled)
mode=$(stat -c '%A' /etc/nginx/sites-enabled)
if [ "$group_owner" != "docker" ]; then
  long_prompt "Chgrp'ing nginx sites-enabled directory to docker group."
  if [ "$reply" = "y" ]; then
    chown root:docker /etc/nginx/sites-enabled 
  fi
fi
if [ "$mode" != "drwxrwxr-x" ]; then
  long_prompt "Chmod'ing nginx sites-enabled directory to be group writable."
  if [ "$reply" = "y" ]; then
    chmod 0775 /etc/nginx/sites-enabled 
  fi
fi

# Setup the data directories and properly chown them
dirs="services services/phpmyadmin services/phpmyadmin/src services/phpmyadmin/env services/databases services/sites"
makedirs=
for dir in $dirs; do
  if [ ! -d "${LONG_SRV}/${dir}" ]; then
    makedirs="$makedirs $dir"
  fi
done
    
if [ -n "$makedirs" ]; then
  long_prompt "Making $makedirs"
  if [ "$reply" = "y" ]; then
    for makedir in $makedirs; do
      mkdir -p "${LONG_SRV}/${makedir}"
      chown "${LONG_HOST_USER}:${LONG_HOST_USER}" "${LONG_SRV}/${makedir}"
    done
  fi
fi

# Set phpmyadmin symlink for nginx to work properly on the host
if [ ! -h /var/www/phpmyadmin ] || [[ $(readlink /var/www/phpmyadmin) != "${LONG_SRV}/services/phpmyadmin/src" ]]; then
  long_prompt "Create phpmyadmin symlink"
  if [ "$reply" = "y" ]; then
    if [ -h /var/www/phpmyadmin ]; then
      rm -f /var/www/phpmyadmin;
    fi
    if [ -f /var/www/phpmyadmin ]; then
      long_die "There seems to be a file or directory in /var/www/phpmyadmin that should be moved by hand."
    fi
    ln -s "${LONG_SRV}/services/phpmyadmin/src" /var/www/phpmyadmin
  fi
fi

# Set platforms symlink for nginx to work properly on the host
if [ ! -h /var/www/powerbase ] || [[ $(readlink /var/www/powerbase) != "${LONG_SRV}/platforms" ]]; then
  long_prompt "Create nginx platforms symlink"
  if [ "$reply" = "y" ]; then
    if [ -h /var/www/powerbase ]; then
      rm -f /var/www/powerbase;
    fi
    if [ -f /var/www/powerbase -o -d /var/www/powerbase ]; then
      long_die "There seems to be a file or directory in /var/www that should be moved by hand."
    fi
    ln -s "${LONG_SRV}/platforms" /var/www/powerbase
  fi
fi
# Setup tls if necessary
if [ -n "$LONG_TLS_KEY_PATH" ]; then
  if [ -z "$LONG_X509_CERT_PATH" -o -z "$LONG_DH_PARAM_PATH" -o -z \
    "$LONG_NGINX_TLS_PATH" ]; then
    long_die "If you want https support, you have define LONG_TLS_KEY_PATH, \
      LONG_x509_CERT_PATH, LONG_DH_PARAM_PATH, and LONG_NGINX_TLS_PATH \
      in longshore.conf"
  fi
  if [ ! -f "$LONG_TLS_KEY_PATH" ]; then
    long_die "Please manually copy the key file to %s" 1 "$LONG_TLS_KEY_PATH"
  fi
  if [ ! -f "$LONG_X509_CERT_PATH" ]; then
    long_die "Please manually copy the crt file to %s" 1 "$LONG_X509_CERT_PATH"
  fi
  if [ ! -f "$LONG_DH_PARAM_PATH" ]; then
    long_prompt "Create dhparams"
    if [ "$reply" = "y" ]; then
      openssl dhparam -out "$LONG_DH_PARAM_PATH" 4096
    fi
  fi
  # Touch and fix ownership for tls.conf file
  touch "$LONG_NGINX_TLS_PATH"
  chown "${LONG_HOST_USER}:${LONG_HOST_USER}" "$LONG_NGINX_TLS_PATH"
fi

# Set autocomplete if necessary
longshore_config_path="/home/${LONG_HOST_USER}"/.config
bash_completion_path="${longshore_config_path}/bash_completion.d"
if [ ! -d "$bash_completion_path" ] || [ ! -f "${bash_completion_path}/longshore" ]; then
  long_prompt "Create bash_completion file for longshore."
  if [ "$reply" = "y" ]; then
    if [ ! -d "$longshore_config_path" ]; then
      mkdir -p "$longshore_config_path" && chown "${LONG_HOST_USER}:${LONG_HOST_USER}" "$longshore_config_path"
    fi
    if [ ! -d "$bash_completion_path" ]; then
      mkdir -p "$bash_completion_path" && chown "${LONG_HOST_USER}:${LONG_HOST_USER}" "$bash_completion_path"
    fi
    ln -s "${LONG_SHARE}/bash-completion/longshore" "${bash_completion_path}/longshore"
    chown --no-dereference "${LONG_HOST_USER}:${LONG_HOST_USER}" "${bash_completion_path}/longshore"
  fi
fi

# Add to PATH
if ! grep /srv/longshore/bin /home/longshore/.profile > /dev/null; then
  echo 'PATH="/srv/longshore/bin:$PATH"' >> /home/longshore/.profile
fi

if ! grep '.config/bash_completion.d' /home/longshore/.profile >/dev/null; then
  echo '
for file in $(find ~/.config/bash_completion.d/ -type f -o -type l); do
  source "$file"
done' >> /home/longshore/.profile
fi


# Check for some settings that should be set manually.
#
# Ensure my.cnf file is here and has the correct permissions.
mycnf="${LONG_ETC}/my.cnf"
if [ ! -f "$mycnf"  ]; then
  printf "Please add %s file with MySQL database connection details.\n" "$mycnf"
else
  # Ensure it is the correct ownership and permission
  chown longshore:longshore "$mycnf"
  chmod 0600 "$mycnf"
fi
# Ensure cron job is set.
if ! crontab -u "$LONG_HOST_USER" -l | grep site-backup > /dev/null; then
  printf "FYI, site-backup cron job is not set.\n"
fi
if ! crontab -u "$LONG_HOST_USER" -l | grep site-cron > /dev/null; then
  printf "FYI, site-cron cron job is not set.\n"
fi
if ! crontab -u "$LONG_HOST_USER" -l | grep sibling-backup > /dev/null; then
  printf "FYI, sibling-backup cron job is not set.\n"
fi
if ! grep "worker_processes auto;" /etc/nginx/nginx.conf > /dev/null; then
  printf "FYI, 'worker_processes auto;' is not set in /etc/nginx/nginx.conf.\n"
fi
if ! grep 'cgroup_enable=memory swapaccount=1' /etc/default/grub >/dev/null; then
  printf "FYI, 'cgroup_enable=memory swapaccount=1' not set in /etc/default/grub.\n"
fi

if ! su - -c 'git config --global user.email' longshore >/dev/null; then
  printf "Please set git user email address for the longshore user with: git config --global user.email support@progressivetech.org\n";
fi

if ! su - -c 'git config --global user.name' longshore >/dev/null; then
  printf "Please set git user name address for the longshore user with: git config --global user.name 'PTP Support'\n";
fi
